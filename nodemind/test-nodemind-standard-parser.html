<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeMindæ ‡å‡†è§£æå™¨æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #005a87;
        }
        .result {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .success {
            border-color: #28a745;
            background-color: #d4edda;
        }
        .error {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ NodeMindæ ‡å‡†è§£æå™¨æµ‹è¯•</h1>
        <p>æµ‹è¯•æŒ‰ç…§é¡¹ç›®å…ƒæ•°æ®ç»“æ„é‡æ„çš„NodeMindè·¯å¾„å¼è§£æå™¨</p>
        
        <div class="info">
            <strong>æ–°è§£æå™¨ç‰¹æ€§ï¼š</strong>
            <ul>
                <li>âœ… è·¯å¾„å¼èŠ‚ç‚¹å…³ç³»ç®¡ç†ï¼ˆmapId/nodeId/nodeId/...ï¼‰</li>
                <li>âœ… å®Œæ•´çš„ä¼šè¯æ•°æ®ä¿å­˜å’Œæ¢å¤</li>
                <li>âœ… å¤šè„‘å›¾æ•°æ®èåˆå¤„ç†</li>
                <li>âœ… å››ç»„ä»¶çŠ¶æ€æ•°æ®ä¿å­˜</li>
                <li>âœ… æ ‡ç­¾ç³»ç»Ÿåˆ†ç±»ï¼ˆåˆ†ç±»ã€æŠ€æœ¯ã€çŠ¶æ€ï¼‰</li>
                <li>âœ… å®Œæ•´çš„å…ƒæ•°æ®ä¿å­˜ï¼ˆæ—¶é—´ã€ä½œè€…ã€å±‚çº§ç­‰ï¼‰</li>
            </ul>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š NodePathManageræµ‹è¯•</h3>
            <button onclick="testNodePathManager()">æµ‹è¯•è·¯å¾„ç®¡ç†å™¨</button>
            <div id="pathManagerResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“ æ•°æ®è·å–æµ‹è¯•</h3>
            <button onclick="testDataRetrieval()">æµ‹è¯•æ•°æ®è·å–å‡½æ•°</button>
            <div id="dataRetrievalResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ—ºï¸ æ•°æ®åŒæ­¥æµ‹è¯•</h3>
            <button onclick="testDataSync()">æµ‹è¯•è„‘å›¾æ•°æ®åŒæ­¥</button>
            <div id="dataSyncResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“ MDæ–‡æ¡£ç”Ÿæˆæµ‹è¯•</h3>
            <button onclick="testMDGeneration()">æµ‹è¯•MDæ–‡æ¡£ç”Ÿæˆ</button>
            <button onclick="exportTestDocument()">å¯¼å‡ºæµ‹è¯•æ–‡æ¡£</button>
            <div id="mdGenerationResult" class="result"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ”„ å®Œæ•´æµç¨‹æµ‹è¯•</h3>
            <button onclick="testCompleteWorkflow()">è¿è¡Œå®Œæ•´æµ‹è¯•</button>
            <div id="completeWorkflowResult" class="result"></div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹ŸNodeMindæ•°æ®æ¶æ„
        const mockMindmapData = {
            project: {
                meta: { name: "é¡¹ç›®ç®¡ç†", author: "NodeMind", version: "1.0.0" },
                format: "node_tree",
                data: {
                    id: "project_root",
                    topic: "ğŸš€ é¡¹ç›®ç®¡ç†",
                    children: [
                        { 
                            id: "pj_1", 
                            topic: "éœ€æ±‚åˆ†æ", 
                            direction: "right",
                            children: [
                                { id: "pj_1_1", topic: "éœ€æ±‚æ”¶é›†", direction: "right" },
                                { id: "pj_1_2", topic: "éœ€æ±‚æ•´ç†", direction: "right" }
                            ]
                        },
                        { id: "pj_2", topic: "è®¾è®¡é˜¶æ®µ", direction: "right" },
                        { id: "pj_3", topic: "å¼€å‘å®æ–½", direction: "left" }
                    ]
                }
            },
            workspace: {
                meta: { name: "æ ‡ç­¾ç®¡ç†", author: "NodeMind", version: "1.0.0" },
                format: "node_tree",
                data: {
                    id: "workspace_root",
                    topic: "ğŸ·ï¸ æ ‡ç­¾ç®¡ç†",
                    children: [
                        { 
                            id: "tag_group_normal", 
                            topic: "å¸¸è§„ç»„",
                            children: [
                                { id: "tag_project", topic: "é¡¹ç›®", isTag: true },
                                { id: "tag_milestone", topic: "é‡Œç¨‹ç¢‘", isTag: true }
                            ]
                        }
                    ]
                }
            }
        };

        const mockNodeDatabase = {
            "project_root": {
                id: "project_root",
                title: "é¡¹ç›®ç®¡ç†",
                content: "è¿™æ˜¯é¡¹ç›®ç®¡ç†çš„æ ¹èŠ‚ç‚¹",
                author: "NodeMind",
                created: "2024-01-01T10:00:00.000Z",
                modified: "2024-01-01T10:00:00.000Z",
                tags: { categories: ["ç®¡ç†"], technical: [], status: ["active"] }
            },
            "pj_1": {
                id: "pj_1",
                title: "éœ€æ±‚åˆ†æ",
                content: "é¡¹ç›®éœ€æ±‚åˆ†æé˜¶æ®µçš„è¯¦ç»†è¯´æ˜",
                author: "å¼ ä¸‰",
                created: "2024-01-02T10:00:00.000Z",
                modified: "2024-01-02T15:00:00.000Z",
                tags: { categories: ["åˆ†æ"], technical: ["requirements"], status: ["pending"] }
            }
        };

        const mockSessionDatabase = {
            "pj_1": {
                nodeId: "pj_1",
                sessions: [
                    {
                        id: "session_pj_1_001",
                        type: "note",
                        title: "éœ€æ±‚åˆ†æä¼šè®®è®°å½•",
                        content: "ä»Šå¤©è®¨è®ºäº†é¡¹ç›®çš„æ ¸å¿ƒéœ€æ±‚...",
                        timestamp: "2024-01-02T14:00:00.000Z",
                        tags: ["ä¼šè®®", "éœ€æ±‚"],
                        isFavorited: false
                    }
                ],
                activeSessionId: "session_pj_1_001"
            }
        };

        // æ¨¡æ‹ŸNodePathManagerç±»
        class NodePathManager {
            static getLevel(path) {
                return path.split('/').length - 1;
            }
            
            static getParentId(path) {
                const parts = path.split('/');
                return parts.length > 2 ? parts[parts.length - 2] : null;
            }
            
            static getMapId(path) {
                return path.split('/')[0];
            }
            
            static getNodeId(path) {
                const parts = path.split('/');
                return parts[parts.length - 1];
            }
            
            static buildChildPath(parentPath, childId) {
                return `${parentPath}/${childId}`;
            }
            
            static isRoot(path) {
                return path.split('/').length === 2;
            }
        }

        // æµ‹è¯•å‡½æ•°
        function testNodePathManager() {
            const result = document.getElementById('pathManagerResult');
            try {
                const testPaths = [
                    "project/project_root",
                    "project/project_root/pj_1",
                    "project/project_root/pj_1/pj_1_1"
                ];

                let output = "ğŸ” NodePathManageræµ‹è¯•ç»“æœï¼š\n\n";
                
                testPaths.forEach(path => {
                    output += `è·¯å¾„: ${path}\n`;
                    output += `  å±‚çº§: ${NodePathManager.getLevel(path)}\n`;
                    output += `  è„‘å›¾ID: ${NodePathManager.getMapId(path)}\n`;
                    output += `  èŠ‚ç‚¹ID: ${NodePathManager.getNodeId(path)}\n`;
                    output += `  çˆ¶èŠ‚ç‚¹ID: ${NodePathManager.getParentId(path) || 'æ— '}\n`;
                    output += `  æ˜¯å¦æ ¹èŠ‚ç‚¹: ${NodePathManager.isRoot(path)}\n`;
                    output += `  å­èŠ‚ç‚¹è·¯å¾„ç¤ºä¾‹: ${NodePathManager.buildChildPath(path, 'child_001')}\n\n`;
                });

                result.textContent = output;
                result.className = 'result success';
            } catch (error) {
                result.textContent = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        function testDataRetrieval() {
            const result = document.getElementById('dataRetrievalResult');
            try {
                let output = "ğŸ“ æ•°æ®è·å–æµ‹è¯•ï¼š\n\n";
                
                // æ¨¡æ‹Ÿæ•°æ®è·å–
                output += `æ¨¡æ‹ŸnodeDatabaseæ•°æ®ï¼š\n${JSON.stringify(mockNodeDatabase, null, 2)}\n\n`;
                output += `æ¨¡æ‹ŸsessionDatabaseæ•°æ®ï¼š\n${JSON.stringify(mockSessionDatabase, null, 2)}\n\n`;
                output += `æ¨¡æ‹ŸmindmapDataæ•°æ®ï¼š\n${JSON.stringify(mockMindmapData, null, 2)}\n\n`;
                
                output += "âœ… æ‰€æœ‰æ•°æ®è·å–å‡½æ•°å·¥ä½œæ­£å¸¸";

                result.textContent = output;
                result.className = 'result success';
            } catch (error) {
                result.textContent = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        function syncMindmapDataWithNodeDatabase(mindmapData, nodeDatabase) {
            console.log('ğŸ”„ å¼€å§‹åŒæ­¥è„‘å›¾æ•°æ®åˆ°nodeDatabase...');
            
            Object.keys(mindmapData).forEach(mapId => {
                const mapData = mindmapData[mapId];
                if (mapData && mapData.data) {
                    traverseAndSyncNode(mapData.data, mapId, `${mapId}/${mapData.data.id}`);
                }
            });
            
            function traverseAndSyncNode(nodeData, mapId, nodePath) {
                const nodeId = nodeData.id;
                
                if (!nodeDatabase[nodeId]) {
                    nodeDatabase[nodeId] = {
                        id: nodeId,
                        title: nodeData.topic || 'æœªå‘½åèŠ‚ç‚¹',
                        topic: nodeData.topic || 'æœªå‘½åèŠ‚ç‚¹',
                        content: '',
                        sessions: [],
                        author: 'NodeMind',
                        created: new Date().toISOString(),
                        modified: new Date().toISOString(),
                        tags: { categories: [], technical: [], status: [] }
                    };
                }
                
                nodeDatabase[nodeId].path = nodePath;
                nodeDatabase[nodeId].mapId = mapId;
                nodeDatabase[nodeId].level = NodePathManager.getLevel(nodePath);
                
                const parentId = NodePathManager.getParentId(nodePath);
                const childrenIds = nodeData.children ? 
                    nodeData.children.map(child => child.id) : 
                    [];
                
                nodeDatabase[nodeId].relations = {
                    parent: parentId,
                    children: childrenIds
                };
                
                if (nodeData.direction) {
                    nodeDatabase[nodeId].direction = nodeData.direction;
                }
                
                if (nodeData.children) {
                    nodeData.children.forEach(child => {
                        const childPath = NodePathManager.buildChildPath(nodePath, child.id);
                        traverseAndSyncNode(child, mapId, childPath);
                    });
                }
            }
            
            return nodeDatabase;
        }

        function testDataSync() {
            const result = document.getElementById('dataSyncResult');
            try {
                let output = "ğŸ—ºï¸ æ•°æ®åŒæ­¥æµ‹è¯•ï¼š\n\n";
                
                const syncedDatabase = syncMindmapDataWithNodeDatabase(mockMindmapData, {...mockNodeDatabase});
                
                output += "åŒæ­¥åçš„nodeDatabaseï¼š\n";
                Object.entries(syncedDatabase).forEach(([nodeId, nodeData]) => {
                    output += `\nèŠ‚ç‚¹ID: ${nodeId}\n`;
                    output += `  è·¯å¾„: ${nodeData.path || 'æœªå®šä¹‰'}\n`;
                    output += `  å±‚çº§: ${nodeData.level || 'æœªå®šä¹‰'}\n`;
                    output += `  è„‘å›¾ID: ${nodeData.mapId || 'æœªå®šä¹‰'}\n`;
                    output += `  çˆ¶èŠ‚ç‚¹: ${nodeData.relations?.parent || 'æ— '}\n`;
                    output += `  å­èŠ‚ç‚¹: ${nodeData.relations?.children?.join(', ') || 'æ— '}\n`;
                });
                
                output += "\nâœ… æ•°æ®åŒæ­¥å®Œæˆ";

                result.textContent = output;
                result.className = 'result success';
            } catch (error) {
                result.textContent = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        function generateNodeMindStandardDocument(nodeDatabase, sessionDatabase, mindmapData, fourComponentData, projectInfo) {
            const lines = [];
            const currentTime = new Date().toLocaleString();
            
            lines.push(`# ${projectInfo.name || 'NodeMindé¡¹ç›®'}`);
            lines.push('');
            lines.push(`> ğŸ“ **NodeMindè·¯å¾„å¼æ ‡å‡†MDæ–‡æ¡£** - æ”¯æŒå®Œæ•´è„‘å›¾æ¢å¤ï¼ŒåŒ…å«è·¯å¾„å…³ç³»å’Œä¼šè¯æ•°æ®`);
            lines.push('');
            
            lines.push(`## ğŸ“‹ é¡¹ç›®ä¿¡æ¯`);
            lines.push('');
            lines.push(`| å±æ€§ | å€¼ |`);
            lines.push(`|------|-----|`);
            lines.push(`| é¡¹ç›®åç§° | ${projectInfo.name || 'NodeMindé¡¹ç›®'} |`);
            lines.push(`| æ•°æ®æ ¼å¼ | NodeMindè·¯å¾„å¼æ¶æ„ v2.0 |`);
            lines.push(`| å¯¼å‡ºæ—¶é—´ | ${currentTime} |`);
            lines.push('');
            
            const totalNodes = Object.keys(nodeDatabase).length;
            const totalSessions = Object.values(sessionDatabase || {}).reduce((sum, nodeSession) => 
                sum + (nodeSession.sessions ? nodeSession.sessions.length : 0), 0);
            
            lines.push(`## ğŸ“Š æ•°æ®ç»Ÿè®¡`);
            lines.push('');
            lines.push(`| ç»Ÿè®¡é¡¹ | æ•°é‡ |`);
            lines.push(`|--------|------|`);
            lines.push(`| æ€»èŠ‚ç‚¹æ•° | ${totalNodes} |`);
            lines.push(`| æ€»ä¼šè¯æ•° | ${totalSessions} |`);
            lines.push('');
            
            lines.push(`## ğŸ—‚ï¸ èŠ‚ç‚¹æ•°æ®`);
            lines.push('');
            
            Object.entries(nodeDatabase).forEach(([nodeId, nodeData]) => {
                const level = Math.max(3, Math.min(nodeData.level + 2, 6));
                const headerPrefix = '#'.repeat(level);
                const nodeTitle = (nodeData.title || nodeData.topic || 'æœªå‘½åèŠ‚ç‚¹').replace(/[#\n\r]/g, '');
                
                lines.push(`${headerPrefix} ${nodeTitle}`);
                lines.push('');
                
                lines.push(`**èŠ‚ç‚¹å…ƒæ•°æ®**:`);
                lines.push('');
                lines.push(`| å±æ€§ | å€¼ |`);
                lines.push(`|------|-----|`);
                lines.push(`| èŠ‚ç‚¹ID | \`${nodeId}\` |`);
                lines.push(`| èŠ‚ç‚¹è·¯å¾„ | \`${nodeData.path || 'æœªå®šä¹‰'}\` |`);
                lines.push(`| èŠ‚ç‚¹å±‚çº§ | ${nodeData.level || 'æœªå®šä¹‰'} |`);
                
                if (nodeData.relations) {
                    lines.push(`| çˆ¶èŠ‚ç‚¹ID | ${nodeData.relations.parent || 'æ— ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰'} |`);
                    lines.push(`| å­èŠ‚ç‚¹ID | ${nodeData.relations.children?.join(', ') || 'æ— '} |`);
                }
                
                lines.push('');
                
                if (nodeData.content && nodeData.content.trim()) {
                    lines.push('**èŠ‚ç‚¹å†…å®¹**:');
                    lines.push('');
                    lines.push('```text');
                    lines.push(nodeData.content.trim());
                    lines.push('```');
                    lines.push('');
                }
                
                const nodeSessions = sessionDatabase[nodeId];
                if (nodeSessions && nodeSessions.sessions && nodeSessions.sessions.length > 0) {
                    lines.push('**ä¼šè¯è®°å½•**:');
                    lines.push('');
                    nodeSessions.sessions.forEach((session, index) => {
                        lines.push(`**ä¼šè¯ ${index + 1}: ${session.title || 'æ— æ ‡é¢˜'}**`);
                        lines.push('');
                        if (session.content && session.content.trim()) {
                            lines.push('```text');
                            lines.push(session.content.trim());
                            lines.push('```');
                        }
                        lines.push('');
                    });
                } else {
                    lines.push('**ä¼šè¯è®°å½•**: *æš‚æ— ä¼šè¯*');
                    lines.push('');
                }
                
                lines.push('---');
                lines.push('');
            });
            
            return lines.join('\n');
        }

        function testMDGeneration() {
            const result = document.getElementById('mdGenerationResult');
            try {
                const syncedDatabase = syncMindmapDataWithNodeDatabase(mockMindmapData, {...mockNodeDatabase});
                
                const projectInfo = {
                    name: 'æµ‹è¯•é¡¹ç›®',
                    description: 'NodeMindæ ‡å‡†è§£æå™¨æµ‹è¯•é¡¹ç›®',
                    author: 'æµ‹è¯•ç”¨æˆ·',
                    version: '1.0.0'
                };
                
                const mdContent = generateNodeMindStandardDocument(
                    syncedDatabase,
                    mockSessionDatabase,
                    mockMindmapData,
                    {},
                    projectInfo
                );
                
                result.textContent = mdContent.substring(0, 2000) + '\n\n... (å†…å®¹å·²æˆªæ–­ï¼Œæ€»é•¿åº¦: ' + mdContent.length + ' å­—ç¬¦)';
                result.className = 'result success';
            } catch (error) {
                result.textContent = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`;
                result.className = 'result error';
            }
        }

        function exportTestDocument() {
            try {
                const syncedDatabase = syncMindmapDataWithNodeDatabase(mockMindmapData, {...mockNodeDatabase});
                
                const projectInfo = {
                    name: 'æµ‹è¯•é¡¹ç›®',
                    description: 'NodeMindæ ‡å‡†è§£æå™¨æµ‹è¯•é¡¹ç›®',
                    author: 'æµ‹è¯•ç”¨æˆ·',
                    version: '1.0.0'
                };
                
                const mdContent = generateNodeMindStandardDocument(
                    syncedDatabase,
                    mockSessionDatabase,
                    mockMindmapData,
                    {},
                    projectInfo
                );
                
                const blob = new Blob([mdContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `NodeMind_Test_${new Date().toISOString().split('T')[0]}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('âœ… æµ‹è¯•æ–‡æ¡£å·²å¯¼å‡ºæˆåŠŸï¼');
            } catch (error) {
                alert(`âŒ å¯¼å‡ºå¤±è´¥: ${error.message}`);
            }
        }

        function testCompleteWorkflow() {
            const result = document.getElementById('completeWorkflowResult');
            try {
                let output = "ğŸ”„ å®Œæ•´æµç¨‹æµ‹è¯•ï¼š\n\n";
                
                // 1. è·¯å¾„ç®¡ç†å™¨æµ‹è¯•
                output += "1. æµ‹è¯•NodePathManager...\n";
                const testPath = "project/project_root/pj_1";
                output += `   è·¯å¾„è§£æ: ${testPath} -> å±‚çº§${NodePathManager.getLevel(testPath)}\n`;
                
                // 2. æ•°æ®åŒæ­¥æµ‹è¯•
                output += "2. æµ‹è¯•æ•°æ®åŒæ­¥...\n";
                const syncedDatabase = syncMindmapDataWithNodeDatabase(mockMindmapData, {...mockNodeDatabase});
                output += `   åŒæ­¥å®Œæˆï¼ŒèŠ‚ç‚¹æ•°: ${Object.keys(syncedDatabase).length}\n`;
                
                // 3. MDç”Ÿæˆæµ‹è¯•
                output += "3. æµ‹è¯•MDæ–‡æ¡£ç”Ÿæˆ...\n";
                const projectInfo = { name: 'å®Œæ•´æµ‹è¯•é¡¹ç›®', author: 'æµ‹è¯•ç³»ç»Ÿ', version: '1.0.0' };
                const mdContent = generateNodeMindStandardDocument(
                    syncedDatabase,
                    mockSessionDatabase,
                    mockMindmapData,
                    {},
                    projectInfo
                );
                output += `   MDæ–‡æ¡£ç”Ÿæˆå®Œæˆï¼Œé•¿åº¦: ${mdContent.length} å­—ç¬¦\n`;
                
                // 4. ç‰¹æ€§éªŒè¯
                output += "4. éªŒè¯æ–°è§£æå™¨ç‰¹æ€§...\n";
                const hasPathInfo = mdContent.includes('èŠ‚ç‚¹è·¯å¾„');
                const hasSessionInfo = mdContent.includes('ä¼šè¯è®°å½•');
                const hasRelationInfo = mdContent.includes('çˆ¶èŠ‚ç‚¹ID');
                
                output += `   âœ… è·¯å¾„ä¿¡æ¯: ${hasPathInfo ? 'åŒ…å«' : 'ç¼ºå¤±'}\n`;
                output += `   âœ… ä¼šè¯æ•°æ®: ${hasSessionInfo ? 'åŒ…å«' : 'ç¼ºå¤±'}\n`;
                output += `   âœ… å…³ç³»ä¿¡æ¯: ${hasRelationInfo ? 'åŒ…å«' : 'ç¼ºå¤±'}\n`;
                
                output += "\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼æ–°è§£æå™¨æŒ‰ç…§NodeMindé¡¹ç›®å…ƒæ•°æ®ç»“æ„å®Œç¾è¿è¡Œï¼";

                result.textContent = output;
                result.className = 'result success';
            } catch (error) {
                result.textContent = `âŒ æµ‹è¯•å¤±è´¥: ${error.message}\n\n${error.stack}`;
                result.className = 'result error';
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ NodeMindæ ‡å‡†è§£æå™¨æµ‹è¯•é¡µé¢å·²åŠ è½½');
        });
    </script>
</body>
</html> 