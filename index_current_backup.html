<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeMind ËÑëÂõæÁªÑ‰ª∂</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .main-content {
            display: flex;
            height: calc(100vh - 140px);
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #495057;
            font-size: 16px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .textarea {
            width: 100%;
            min-height: 350px;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }

        .node-content-editor {
            margin-top: 15px;
            padding: 15px;
            border: 2px solid #ff6b35;
            border-radius: 8px;
            background: #fff8f5;
        }

        .node-content-editor h4 {
            margin: 0 0 10px 0;
            color: #ff6b35;
            font-size: 14px;
        }

        .node-content-editor textarea {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .node-content-editor .btn-group {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .node-content-editor .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-save:hover {
            background: #218838;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
        }

        .btn-cancel:hover {
            background: #5a6268;
        }

        .mindmap-container {
            flex: 1;
            position: relative;
            background: white;
        }

        .mindmap-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .mindmap-svg:active {
            cursor: grabbing;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node rect {
            fill: #4facfe;
            stroke: #0288d1;
            stroke-width: 2;
            rx: 8;
            ry: 8;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .node:hover rect {
            fill: #29b6f6;
            stroke: #0277bd;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
        }

        .node.selected rect {
            fill: #ff6b35;
            stroke: #e55a2b;
            stroke-width: 3;
            filter: drop-shadow(0 4px 12px rgba(255,107,53,0.3));
        }

        .node text {
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 14px;
            font-weight: 500;
            pointer-events: none;
        }

        .node-editor {
            position: absolute;
            background: white;
            border: 2px solid #4facfe;
            border-radius: 6px;
            padding: 8px;
            min-width: 120px;
            font-size: 14px;
            font-family: inherit;
            text-align: center;
            outline: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        .link {
            fill: none;
            stroke: #90a4ae;
            stroke-width: 2;
            opacity: 0.8;
        }

        .relationship-link {
            fill: none;
            stroke-width: 2;
            opacity: 0.7;
            stroke-dasharray: 5,5;
        }

        .relationship-link.reference {
            stroke: #ff7043;
        }

        .relationship-link.dependency {
            stroke: #ab47bc;
        }

        .relationship-link.association {
            stroke: #26a69a;
        }

        .status-bar {
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            padding: 10px 20px;
            font-size: 12px;
            color: #6c757d;
        }

        .example-data {
            margin-bottom: 15px;
        }

        .example-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .example-btn:hover {
            background: #138496;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #495057;
        }

        .zoom-btn:hover {
            background: #f8f9fa;
        }

        .shortcuts-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .shortcuts-info h4 {
            margin-bottom: 8px;
            color: #1976d2;
        }

        .shortcuts-info ul {
            margin: 0;
            padding-left: 16px;
        }

        .shortcuts-info li {
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† NodeMind ËÑëÂõæÁªÑ‰ª∂</h1>
            <div class="controls">
                <button class="btn btn-primary" onclick="mindMap.fitToView()">ÈÄÇÂ∫îËßÜÂõæ</button>
                <button class="btn btn-primary" onclick="mindMap.exportData()">ÂØºÂá∫Êï∞ÊçÆ</button>
                <button class="btn btn-primary" onclick="location.reload()">ÈáçÁΩÆ</button>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>üìù Markdown ËæìÂÖ•</h3>
                
                <div class="shortcuts-info">
                    <h4>‚å®Ô∏è Âø´Êç∑ÈîÆÊìç‰Ωú</h4>
                    <ul>
                        <li><strong>Enter</strong>ÔºöÊ∑ªÂä†ÂêåÁ∫ßËäÇÁÇπ</li>
                        <li><strong>Ctrl+Enter</strong>ÔºöÊ∑ªÂä†Â≠êËäÇÁÇπ</li>
                        <li><strong>ÂèåÂáª</strong>ÔºöÁºñËæëËäÇÁÇπÊñáÊú¨</li>
                        <li><strong>Del</strong>ÔºöÂà†Èô§ÈÄâ‰∏≠ËäÇÁÇπ</li>
                        <li><strong>Esc</strong>ÔºöÂèñÊ∂àÈÄâÊã©</li>
                    </ul>
                </div>
                
                <div class="example-data">
                    <button class="example-btn" onclick="loadExample('project')">È°πÁõÆÁÆ°ÁêÜ</button>
                    <button class="example-btn" onclick="loadExample('knowledge')">Áü•ËØÜ‰ΩìÁ≥ª</button>
                    <button class="example-btn" onclick="loadExample('learning')">Â≠¶‰π†Á¨îËÆ∞</button>
                </div>

                <div class="input-group">
                    <label for="markdown-input">MDÊñáÊ°£ÂÜÖÂÆπÔºö</label>
                    <textarea id="markdown-input" class="textarea" 
                              placeholder="ËæìÂÖ•Á¨¶ÂêàÁ¨îËÆ∞ÂùóÊ†ºÂºèÁöÑMarkdownÂÜÖÂÆπ..."
                              oninput="updateMindMap()">ÁºñÂè∑Ôºö{#N001}
Ê†áÈ¢òÔºöNodeMind ËÑëÂõæÁ≥ªÁªü
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂºÄÂèëÂõ¢Èòü

ËøôÊòØNodeMindËÑëÂõæÁ≥ªÁªüÁöÑÊ†∏ÂøÉÊ®°ÂùóÔºåË¥üË¥£Â§ÑÁêÜÁ¨îËÆ∞ÂùóÁöÑÂèØËßÜÂåñÂ±ïÁ§∫„ÄÇ

‰∏ªË¶ÅÂäüËÉΩÔºö
- Ëß£ÊûêMDÊñáÊ°£‰∏≠ÁöÑÁ¨îËÆ∞Âùó
- ÊûÑÂª∫ËäÇÁÇπÂÖ≥Á≥ªÂõæ
- Êèê‰æõ‰∫§‰∫íÂºèÁºñËæëÂäüËÉΩ

---
„ÄêÊ†áËÆ∞Êóè„Äë
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Á≥ªÁªü.Ê†∏ÂøÉ.ÂèØËßÜÂåñ
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.JavaScript.D3
Áä∂ÊÄÅÊ†áÁ≠æÔºö@ÂºÄÂèë‰∏≠

ÁºñÂè∑Ôºö{#N002}
Ê†áÈ¢òÔºöÊï∞ÊçÆËß£ÊûêÂºïÊìé
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂºÄÂèëÂõ¢Èòü

Ë¥üË¥£Ëß£ÊûêMarkdownÊñáÊ°£ÔºåÊèêÂèñÁ¨îËÆ∞ÂùóÂíåÂÖ≥Á≥ª‰ø°ÊÅØ„ÄÇ

Ê†∏ÂøÉËÉΩÂäõÔºö
- Á¨îËÆ∞ÂùóÊèêÂèñ
- ÂÖ≥Á≥ªÁ¨¶Âè∑Ëß£Êûê
- Ê†áËÆ∞ÊóèËß£Êûê

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^N001
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Á≥ªÁªü.Ê†∏ÂøÉ.Ëß£Êûê
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.JavaScript.Ê≠£ÂàôË°®ËææÂºè

ÁºñÂè∑Ôºö{#N003}
Ê†áÈ¢òÔºöÊ∏≤ÊüìÂºïÊìé
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂºÄÂèëÂõ¢Èòü

Âü∫‰∫éD3.jsÁöÑÂõæÂΩ¢Ê∏≤ÊüìÂºïÊìéÔºåË¥üË¥£ËÑëÂõæÁöÑÂèØËßÜÂåñÂ±ïÁ§∫„ÄÇ

‰∏ªË¶ÅÁâπÊÄßÔºö
- Âä®ÊÄÅÂ∏ÉÂ±ÄÁÆóÊ≥ï
- ËäÇÁÇπ‰∫§‰∫íÊéßÂà∂
- ÂÖ≥Á≥ªÁ∫øÊ∏≤Êüì

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^N001
‰æùËµñÂÖ≥Á≥ªÔºö‚ÜêN002
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Á≥ªÁªü.Ê†∏ÂøÉ.Ê∏≤Êüì
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.D3js.SVG</textarea>
                </div>

                <!-- ËäÇÁÇπÂÜÖÂÆπÁºñËæëÂô® -->
                <div id="node-content-editor" class="node-content-editor" style="display: none;">
                    <h4>üìù ÁºñËæëËäÇÁÇπÂÜÖÂÆπ</h4>
                    <div>
                        <strong>ËäÇÁÇπIDÔºö</strong><span id="editing-node-id">Êó†</span>
                    </div>
                    <div style="margin-top: 8px;">
                        <strong>ËäÇÁÇπÊ†áÈ¢òÔºö</strong><span id="editing-node-title">Êó†</span>
                    </div>
                    <textarea id="node-content-textarea" placeholder="ÁºñËæëËäÇÁÇπÁöÑËØ¶ÁªÜÂÜÖÂÆπ..."></textarea>
                    <div class="btn-group">
                        <button class="btn-small btn-save" onclick="saveNodeContent()">‰øùÂ≠ò</button>
                        <button class="btn-small btn-cancel" onclick="cancelNodeEdit()">ÂèñÊ∂à</button>
                    </div>
                </div>

                <div class="input-group">
                    <label>Â∏ÉÂ±ÄÁÆóÊ≥ïÔºö</label>
                    <select id="layout-select" onchange="updateLayout()">
                        <option value="horizontal">Ê†áÂáÜÊ∞¥Âπ≥Ê†ë</option>
                        <option value="vertical">ÂûÇÁõ¥Ê†ëÂ∏ÉÂ±Ä</option>
                        <option value="radial">ÂæÑÂêëËæêÂ∞ÑÂ∏ÉÂ±Ä</option>
                        <option value="circle">ÂúÜÂΩ¢ÂàÜÂ±ÇÂ∏ÉÂ±Ä</option>
                        <option value="compact">Á¥ßÂáëËá™ÈÄÇÂ∫îÂ∏ÉÂ±Ä</option>
                        <option value="fishbone">È±ºÈ™®‰∫§ÊõøÂ∏ÉÂ±Ä</option>
                    </select>
                </div>
            </div>

            <div class="mindmap-container">
                <svg id="mindmap-svg" class="mindmap-svg"></svg>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="mindMap.zoomIn()">+</button>
                    <button class="zoom-btn" onclick="mindMap.zoomOut()">-</button>
                    <button class="zoom-btn" onclick="mindMap.fitToView()">‚åÇ</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="status-text">ÂáÜÂ§áÂ∞±Áª™ | ËäÇÁÇπÊï∞: 0 | ÂÖ≥Á≥ªÊï∞: 0 | Êìç‰ΩúÊèêÁ§∫ÔºöÁÇπÂáªËäÇÁÇπÈÄâÊã©ÔºåEnterÊ∑ªÂä†ÂêåÁ∫ßÔºåCtrl+EnterÊ∑ªÂä†Â≠êËäÇÁÇπ</span>
        </div>
    </div>

    <script>
        class NodeMindMap {
            constructor(svgSelector) {
                this.svg = d3.select(svgSelector);
                this.width = 1000;
                this.height = 600;
                this.data = null;
                this.nodes = [];
                this.links = [];
                this.simulation = null;
                this.transform = d3.zoomIdentity;
                this.selectedNode = null;
                this.editingNode = null;
                this.editingNodeContent = null;
                this.nextNodeId = 4; // ‰ªéN004ÂºÄÂßã
                
                this.init();
                this.setupKeyboardEvents();
            }

            init() {
                this.svg.attr('viewBox', `0 0 ${this.width} ${this.height}`);
                
                // Ê∑ªÂä†Áº©ÊîæÂäüËÉΩ
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.transform = event.transform;
                        this.container.attr('transform', this.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // ÂàõÂª∫ÂÆπÂô®ÁªÑ
                this.container = this.svg.append('g');
                this.linksGroup = this.container.append('g').attr('class', 'links');
                this.nodesGroup = this.container.append('g').attr('class', 'nodes');

                // ÁÇπÂáªÁ©∫ÁôΩÂ§ÑÂèñÊ∂àÈÄâÊã©
                this.svg.on('click', (event) => {
                    if (event.target === event.currentTarget) {
                        this.selectNode(null);
                    }
                });
            }

            setupKeyboardEvents() {
                document.addEventListener('keydown', (event) => {
                    // Â¶ÇÊûúÂú®ÁºñËæëÁä∂ÊÄÅÔºå‰∏çÂ§ÑÁêÜÂø´Êç∑ÈîÆ
                    if (this.editingNode) return;
                    
                    switch(event.key) {
                        case 'Enter':
                            event.preventDefault();
                            if (event.ctrlKey) {
                                this.addChildNode();
                            } else {
                                this.addSiblingNode();
                            }
                            break;
                        case 'Delete':
                        case 'Backspace':
                            event.preventDefault();
                            this.deleteSelectedNode();
                            break;
                        case 'Escape':
                            this.selectNode(null);
                            break;
                    }
                });
            }

            selectNode(nodeId) {
                // ÁßªÈô§‰πãÂâçÁöÑÈÄâÊã©Áä∂ÊÄÅ
                this.nodesGroup.selectAll('.node').classed('selected', false);
                
                if (nodeId) {
                    // Ê∑ªÂä†Êñ∞ÁöÑÈÄâÊã©Áä∂ÊÄÅ
                    this.nodesGroup.selectAll('.node')
                        .filter(d => (d.id || d.data.id) === nodeId)
                        .classed('selected', true);
                    this.selectedNode = nodeId;
                    
                    // ÊòæÁ§∫ËäÇÁÇπÂÜÖÂÆπÁºñËæëÂô®
                    this.showNodeEditor(nodeId);
                } else {
                    this.selectedNode = null;
                    this.hideNodeEditor();
                }
                
                this.updateStatus();
            }

            showNodeEditor(nodeId) {
                const nodeData = this.nodes.find(n => n.id === nodeId);
                if (!nodeData) return;

                const editor = document.getElementById('node-content-editor');
                const nodeIdSpan = document.getElementById('editing-node-id');
                const nodeTitleSpan = document.getElementById('editing-node-title');
                const textarea = document.getElementById('node-content-textarea');

                nodeIdSpan.textContent = nodeData.id;
                nodeTitleSpan.textContent = nodeData.title;
                textarea.value = this.extractNodeContent(nodeData);
                
                editor.style.display = 'block';
                this.editingNodeContent = nodeId;
            }

            hideNodeEditor() {
                const editor = document.getElementById('node-content-editor');
                editor.style.display = 'none';
                this.editingNodeContent = null;
            }

            extractNodeContent(nodeData) {
                // ‰ªéMDÊñáÊ°£‰∏≠ÊèêÂèñËØ•ËäÇÁÇπÁöÑÂÆåÊï¥ÂÜÖÂÆπ
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // Êü•ÊâæËØ•ËäÇÁÇπÁöÑÂÆåÊï¥Âùó
                const nodePattern = new RegExp(`ÁºñÂè∑Ôºö\\{#${nodeData.id}\\}[\\s\\S]*?(?=ÁºñÂè∑Ôºö\\{#|$)`, 'g');
                const match = nodePattern.exec(content);
                
                if (match) {
                    return match[0].trim();
                } else {
                    // Â¶ÇÊûúÊ≤°ÊâæÂà∞ÔºåËøîÂõûÂü∫Êú¨Ê†ºÂºè
                    return `ÁºñÂè∑Ôºö{#${nodeData.id}}
Ê†áÈ¢òÔºö${nodeData.title}
Êó∂Èó¥Ôºö${nodeData.time}
‰ΩúËÄÖÔºö${nodeData.author}

${nodeData.content}

---
„ÄêÊ†áËÆ∞Êóè„Äë
${nodeData.data.relations.parent ? `Áà∂Â≠êÂÖ≥Á≥ªÔºö^${nodeData.data.relations.parent}\n` : ''}ÂàÜÁ±ªÊ†áÁ≠æÔºö@${nodeData.data.tags.categories.join('.')}
${nodeData.data.tags.technical.length > 0 ? `ÊäÄÊúØÊ†áÁ≠æÔºö@${nodeData.data.tags.technical.join('.')}\n` : ''}${nodeData.data.tags.status.length > 0 ? `Áä∂ÊÄÅÊ†áÁ≠æÔºö@${nodeData.data.tags.status.join('.')}` : ''}`;
                }
            }

            saveNodeContent() {
                if (!this.editingNodeContent) return;

                const textarea = document.getElementById('node-content-textarea');
                const newContent = textarea.value.trim();
                
                if (!newContent) {
                    alert('ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫');
                    return;
                }

                // Êõ¥Êñ∞MDÊñáÊ°£
                this.updateNodeInMarkdown(this.editingNodeContent, newContent);
                
                // ÈáçÊñ∞Âä†ËΩΩËÑëÂõæ
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // ÈáçÊñ∞ÈÄâÊã©ËØ•ËäÇÁÇπ
                setTimeout(() => {
                    this.selectNode(this.editingNodeContent);
                }, 100);

                alert('ËäÇÁÇπÂÜÖÂÆπÂ∑≤‰øùÂ≠ò');
            }

            cancelNodeEdit() {
                this.hideNodeEditor();
                this.selectNode(null);
            }

            updateNodeInMarkdown(nodeId, newContent) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // ÊõøÊç¢ËØ•ËäÇÁÇπÁöÑÂÜÖÂÆπ
                const nodePattern = new RegExp(`ÁºñÂè∑Ôºö\\{#${nodeId}\\}[\\s\\S]*?(?=ÁºñÂè∑Ôºö\\{#|$)`, 'g');
                const newMarkdown = content.replace(nodePattern, newContent + '\n\n');
                
                textarea.value = newMarkdown.trim();
            }

            addSiblingNode() {
                if (!this.selectedNode) {
                    alert('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËäÇÁÇπ');
                    return;
                }

                const selectedNodeData = this.nodes.find(n => n.id === this.selectedNode);
                if (!selectedNodeData) return;

                const newId = `N${String(this.nextNodeId++).padStart(3, '0')}`;
                const newTitle = `Êñ∞ËäÇÁÇπ ${newId}`;
                
                // Ê∑ªÂä†Âà∞MDÊñáÊ°£
                this.addNodeToMarkdown(newId, newTitle, selectedNodeData.data.relations.parent);
                
                // Âà∑Êñ∞ËÑëÂõæ
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // ÈÄâÊã©Êñ∞ËäÇÁÇπ
                setTimeout(() => {
                    this.selectNode(newId);
                    this.editNode(newId);
                }, 100);
            }

            addChildNode() {
                if (!this.selectedNode) {
                    alert('ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ËäÇÁÇπ');
                    return;
                }

                const newId = `N${String(this.nextNodeId++).padStart(3, '0')}`;
                const newTitle = `Â≠êËäÇÁÇπ ${newId}`;
                
                // Ê∑ªÂä†Âà∞MDÊñáÊ°£ÔºåÁà∂ËäÇÁÇπÊòØÂΩìÂâçÈÄâ‰∏≠ÁöÑËäÇÁÇπ
                this.addNodeToMarkdown(newId, newTitle, this.selectedNode);
                
                // Âà∑Êñ∞ËÑëÂõæ
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // ÈÄâÊã©Êñ∞ËäÇÁÇπ
                setTimeout(() => {
                    this.selectNode(newId);
                    this.editNode(newId);
                }, 100);
            }

            addNodeToMarkdown(id, title, parentId = null) {
                const textarea = document.getElementById('markdown-input');
                const currentContent = textarea.value;
                
                const newNodeContent = `

ÁºñÂè∑Ôºö{#${id}}
Ê†áÈ¢òÔºö${title}
Êó∂Èó¥Ôºö${new Date().toISOString().split('T')[0]} | ${new Date().toISOString().split('T')[0]}
‰ΩúËÄÖÔºöÁî®Êà∑

Êñ∞ËäÇÁÇπÂÜÖÂÆπ...

‰∏ªË¶ÅÂäüËÉΩÔºö
- ÂäüËÉΩÊèèËø∞1
- ÂäüËÉΩÊèèËø∞2

---
„ÄêÊ†áËÆ∞Êóè„Äë${parentId ? `
Áà∂Â≠êÂÖ≥Á≥ªÔºö^${parentId}` : ''}
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Êñ∞Âª∫.ËäÇÁÇπ
Áä∂ÊÄÅÊ†áÁ≠æÔºö@ÁºñËæë‰∏≠`;

                textarea.value = currentContent + newNodeContent;
            }

            deleteSelectedNode() {
                if (!this.selectedNode) {
                    alert('ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÂà†Èô§ÁöÑËäÇÁÇπ');
                    return;
                }

                if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§ËäÇÁÇπ "${this.selectedNode}" ÂêóÔºü`)) {
                    this.removeNodeFromMarkdown(this.selectedNode);
                    this.loadMarkdown(document.getElementById('markdown-input').value);
                    this.selectNode(null);
                }
            }

            removeNodeFromMarkdown(nodeId) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÂà†Èô§ÊåáÂÆöËäÇÁÇπ
                const nodePattern = new RegExp(`ÁºñÂè∑Ôºö\\{#${nodeId}\\}[\\s\\S]*?(?=ÁºñÂè∑Ôºö\\{#|$)`, 'g');
                const newContent = content.replace(nodePattern, '').trim();
                
                textarea.value = newContent;
            }

            editNode(nodeId) {
                const nodeElement = this.nodesGroup.selectAll('.node')
                    .filter(d => d.id === nodeId);
                
                if (nodeElement.empty()) return;

                const nodeData = nodeElement.datum();
                const rect = nodeElement.select('rect').node();
                const rectBBox = rect.getBBox();
                const transform = nodeElement.attr('transform');
                
                // Ëß£ÊûêtransformÂ±ûÊÄßËé∑Âèñ‰ΩçÁΩÆ
                const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                if (!translateMatch) return;
                
                const x = parseFloat(translateMatch[1]);
                const y = parseFloat(translateMatch[2]);
                
                // ÂàõÂª∫ÁºñËæëËæìÂÖ•Ê°Ü
                const editor = document.createElement('input');
                editor.className = 'node-editor';
                editor.value = nodeData.title;
                editor.style.left = (x + rectBBox.x) + 'px';
                editor.style.top = (y + rectBBox.y - 5) + 'px';
                editor.style.width = Math.max(120, rectBBox.width) + 'px';
                
                document.querySelector('.mindmap-container').appendChild(editor);
                
                this.editingNode = nodeId;
                editor.focus();
                editor.select();
                
                const finishEditing = () => {
                    const newTitle = editor.value.trim() || nodeData.title;
                    this.updateNodeTitle(nodeId, newTitle);
                    editor.remove();
                    this.editingNode = null;
                };
                
                editor.addEventListener('blur', finishEditing);
                editor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEditing();
                    } else if (e.key === 'Escape') {
                        editor.remove();
                        this.editingNode = null;
                    }
                });
            }

            updateNodeTitle(nodeId, newTitle) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊõ¥Êñ∞ËäÇÁÇπÊ†áÈ¢ò
                const titlePattern = new RegExp(`(ÁºñÂè∑Ôºö\\{#${nodeId}\\}\\s*\\nÊ†áÈ¢òÔºö)[^\\n]+`, 'g');
                const newContent = content.replace(titlePattern, `$1${newTitle}`);
                
                textarea.value = newContent;
                this.loadMarkdown(newContent);
            }

            parseMarkdown(markdown) {
                const blocks = [];
                
                // ÂÖàÊåâÁºñÂè∑ÂàÜÂâ≤ÊñáÊ°£
                const sections = markdown.split(/(?=ÁºñÂè∑Ôºö\{#[^}]+\})/);
                
                sections.forEach(section => {
                    if (!section.trim()) return;
                    
                    // Ëß£ÊûêÊØè‰∏™section
                    const headerMatch = section.match(/ÁºñÂè∑Ôºö\{#([^}]+)\}\s*\nÊ†áÈ¢òÔºö([^\n]+)\s*\nÊó∂Èó¥Ôºö([^\n]+)\s*\n‰ΩúËÄÖÔºö([^\n]+)\s*\n([\s\S]*?)(?=---\s*„ÄêÊ†áËÆ∞Êóè„Äë|$)/);
                    
                    if (!headerMatch) return;
                    
                    const [, id, title, time, author, content] = headerMatch;
                    
                    const block = {
                        id: id.trim(),
                        title: title.trim(),
                        time: time.trim(),
                        author: author.trim(),
                        content: content.trim(),
                        relations: {
                            parent: null,
                            references: [],
                            dependencies: [],
                            associations: []
                        },
                        tags: {
                            categories: [],
                            technical: [],
                            status: []
                        }
                    };
                    
                    // Ëß£ÊûêÂÖ≥Á≥ªÊ†áËÆ∞
                    const relationMatch = section.match(/---\s*„ÄêÊ†áËÆ∞Êóè„Äë\s*([\s\S]*?)(?=ÁºñÂè∑Ôºö\{#|$)/);
                    
                    if (relationMatch) {
                        const relationText = relationMatch[1];
                        
                        // Ëß£ÊûêÂêÑÁßçÂÖ≥Á≥ª
                        const parentMatch = relationText.match(/Áà∂Â≠êÂÖ≥Á≥ªÔºö\^([^\s\n]+)/);
                        if (parentMatch) {
                            block.relations.parent = parentMatch[1];
                        }
                        
                        const refMatches = relationText.match(/ÂºïÁî®ÂÖ≥Á≥ªÔºö((?:‚Üí[^\s\n]+\s*)+)/);
                        if (refMatches) {
                            block.relations.references = refMatches[1].match(/‚Üí([^\s\n]+)/g)?.map(r => r.slice(1)) || [];
                        }
                        
                        const depMatches = relationText.match(/‰æùËµñÂÖ≥Á≥ªÔºö((?:‚Üê[^\s\n]+\s*)+)/);
                        if (depMatches) {
                            block.relations.dependencies = depMatches[1].match(/‚Üê([^\s\n]+)/g)?.map(d => d.slice(1)) || [];
                        }
                        
                        // Ëß£ÊûêÊ†áÁ≠æ
                        const categoryMatches = relationText.match(/ÂàÜÁ±ªÊ†áÁ≠æÔºö@([^\n]+)/);
                        if (categoryMatches) {
                            block.tags.categories = categoryMatches[1].split('.').map(t => t.trim());
                        }
                        
                        const techMatches = relationText.match(/ÊäÄÊúØÊ†áÁ≠æÔºö@([^\n]+)/);
                        if (techMatches) {
                            block.tags.technical = techMatches[1].split('.').map(t => t.trim());
                        }
                        
                        const statusMatches = relationText.match(/Áä∂ÊÄÅÊ†áÁ≠æÔºö@([^\n]+)/);
                        if (statusMatches) {
                            block.tags.status = statusMatches[1].split('.').map(t => t.trim());
                        }
                    }
                    
                    blocks.push(block);
                });
                
                // Êõ¥Êñ∞nextNodeId
                blocks.forEach(block => {
                    const idNum = parseInt(block.id.replace(/\D/g, ''));
                    if (idNum >= this.nextNodeId) {
                        this.nextNodeId = idNum + 1;
                    }
                });
                
                return blocks;
            }

            buildGraph(blocks) {
                // ÊûÑÂª∫ËäÇÁÇπ
                this.nodes = blocks.map(block => ({
                    id: block.id,
                    title: block.title,
                    content: block.content,
                    data: block,
                    x: Math.random() * this.width,
                    y: Math.random() * this.height
                }));
                
                // ÊûÑÂª∫ËøûÊé•
                this.links = [];
                
                blocks.forEach(block => {
                    // Áà∂Â≠êÂÖ≥Á≥ª
                    if (block.relations.parent) {
                        this.links.push({
                            source: block.relations.parent,
                            target: block.id,
                            type: 'hierarchy'
                        });
                    }
                    
                    // ÂºïÁî®ÂÖ≥Á≥ª
                    block.relations.references.forEach(ref => {
                        this.links.push({
                            source: block.id,
                            target: ref,
                            type: 'reference'
                        });
                    });
                    
                    // ‰æùËµñÂÖ≥Á≥ª
                    block.relations.dependencies.forEach(dep => {
                        this.links.push({
                            source: dep,
                            target: block.id,
                            type: 'dependency'
                        });
                    });
                });
                
                // Êõ¥Êñ∞Áä∂ÊÄÅ
                this.updateStatus();
            }

            render() {
                const rootNodes = this.nodes.filter(n => !n.data.relations.parent);
                if (rootNodes.length === 0) return;
                
                const root = rootNodes[0];
                const layoutType = document.getElementById('layout-select').value;
                
                // Ê†πÊçÆÈÄâÊã©ÁöÑÂ∏ÉÂ±ÄÁ±ªÂûãË∞ÉÁî®‰∏çÂêåÁöÑÂ∏ÉÂ±ÄÁÆóÊ≥ï
                switch(layoutType) {
                    case 'horizontal':
                        this.renderHorizontalTree(root);
                        break;
                    case 'vertical':
                        this.renderVerticalTree(root);
                        break;
                    case 'radial':
                        this.renderRadialLayout(root);
                        break;
                    case 'circle':
                        this.renderCircleLayout(root);
                        break;
                    case 'compact':
                        this.renderCompactLayout(root);
                        break;
                    case 'fishbone':
                        this.renderFishboneLayout(root);
                        break;
                    default:
                        this.renderHorizontalTree(root);
                }
            }

            // 1. Ê†áÂáÜÊ∞¥Âπ≥Ê†ëÂ∏ÉÂ±Ä
            renderHorizontalTree(root) {
                const hierarchy = this.buildHierarchy(root);
                const treeLayout = d3.tree()
                    .size([this.height - 100, this.width - 200])
                    .separation((a, b) => (a.parent === b.parent ? 1.5 : 2.5) / a.depth);
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const temp = d.x;
                    d.x = d.y + 100;
                    d.y = temp + 50;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 2. ÂûÇÁõ¥Ê†ëÂ∏ÉÂ±Ä
            renderVerticalTree(root) {
                const hierarchy = this.buildHierarchy(root);
                const treeLayout = d3.tree()
                    .size([this.width - 200, this.height - 100])
                    .separation((a, b) => (a.parent === b.parent ? 1.2 : 2) / a.depth);
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    d.x = d.x + 100;
                    d.y = d.y + 50;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 3. ÂæÑÂêëËæêÂ∞ÑÂ∏ÉÂ±Ä
            renderRadialLayout(root) {
                const hierarchy = this.buildHierarchy(root);
                const radius = Math.min(this.width, this.height) / 2 - 100;
                const tree = d3.cluster().size([2 * Math.PI, radius]);
                
                const treeRoot = d3.hierarchy(hierarchy);
                tree(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const angle = d.x;
                    const r = d.y;
                    d.x = Math.cos(angle - Math.PI / 2) * r + this.width / 2;
                    d.y = Math.sin(angle - Math.PI / 2) * r + this.height / 2;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 4. ÂúÜÂΩ¢ÂàÜÂ±ÇÂ∏ÉÂ±Ä
            renderCircleLayout(root) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                // ÊåâÂ±ÇÁ∫ßÂàÜÁªÑ
                const levels = this.groupByLevel();
                const descendants = [];
                
                Object.keys(levels).forEach(levelStr => {
                    const level = parseInt(levelStr);
                    const nodes = levels[level];
                    
                    if (level === 0) {
                        // Ê†πËäÇÁÇπÂ±Ö‰∏≠
                        nodes[0].x = centerX;
                        nodes[0].y = centerY;
                        descendants.push(nodes[0]);
                    } else {
                        // ÂÖ∂‰ªñÂ±ÇÁ∫ßÂõ¥Áªï‰∏≠ÂøÉÂúÜÂΩ¢ÂàÜÂ∏É
                        const radius = level * 120;
                        const angleStep = (2 * Math.PI) / nodes.length;
                        
                        nodes.forEach((node, i) => {
                            const angle = i * angleStep;
                            node.x = centerX + Math.cos(angle) * radius;
                            node.y = centerY + Math.sin(angle) * radius;
                            descendants.push(node);
                        });
                    }
                });
                
                this.renderNodesAndLinksCustom(descendants);
            }

            // 5. Á¥ßÂáëËá™ÈÄÇÂ∫îÂ∏ÉÂ±Ä
            renderCompactLayout(root) {
                const hierarchy = this.buildHierarchy(root);
                
                // Âä®ÊÄÅËÆ°ÁÆóÂ∞∫ÂØ∏
                const maxNodes = Math.max(...this.getLevelCounts(hierarchy));
                const dynamicWidth = Math.max(this.width, maxNodes * 140);
                const dynamicHeight = Math.max(this.height, this.getMaxDepth(hierarchy) * 80);
                
                const treeLayout = d3.tree()
                    .size([dynamicHeight - 100, dynamicWidth - 200])
                    .separation((a, b) => {
                        const baseDistance = a.parent === b.parent ? 1.2 : 2;
                        const nodeCountFactor = a.parent ? Math.max(1, a.parent.children.length / 8) : 1;
                        return baseDistance * nodeCountFactor;
                    });
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const temp = d.x;
                    d.x = d.y + 100;
                    d.y = temp + 50;
                });
                
                // Á¢∞ÊíûÊ£ÄÊµãÂíåË∞ÉÊï¥
                this.adjustForCollisions(descendants);
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 6. È±ºÈ™®‰∫§ÊõøÂ∏ÉÂ±Ä
            renderFishboneLayout(root) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const descendants = [];
                
                // Ê†πËäÇÁÇπÂ±Ö‰∏≠
                root.x = centerX;
                root.y = centerY;
                descendants.push(root);
                
                // Ëé∑ÂèñÂ≠êËäÇÁÇπÂπ∂ÊåâÂ±ÇÁ∫ßÂàÜÂ∏É
                const children = this.nodes.filter(n => n.data.relations.parent === root.id);
                children.forEach((child, i) => {
                    const side = i % 2 === 0 ? -1 : 1; // Â∑¶Âè≥‰∫§Êõø
                    const layer = Math.floor(i / 2) + 1;
                    child.x = centerX + side * (150 + layer * 50);
                    child.y = centerY + (i % 2 === 0 ? -1 : 1) * layer * 60;
                    descendants.push(child);
                    
                    // Â§ÑÁêÜÂ≠ôËäÇÁÇπ
                    const grandChildren = this.nodes.filter(n => n.data.relations.parent === child.id);
                    grandChildren.forEach((grandChild, j) => {
                        grandChild.x = child.x + side * 100;
                        grandChild.y = child.y + (j - grandChildren.length / 2) * 40;
                        descendants.push(grandChild);
                    });
                });
                
                this.renderNodesAndLinksCustom(descendants);
            }

            // Ê∏≤ÊüìËäÇÁÇπÂíåËøûÁ∫øÁöÑÈÄöÁî®ÊñπÊ≥ï
            renderNodesAndLinks(descendants, links) {
                // Ê∏≤ÊüìËøûÊé•Á∫ø
                const link = this.linksGroup.selectAll('.link')
                    .data(links)
                    .enter().append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkHorizontal()
                        .x(d => d.x)
                        .y(d => d.y))
                    .attr('stroke', '#90a4ae')
                    .attr('stroke-width', 2)
                    .attr('fill', 'none');
                
                this.renderNodes(descendants);
            }

            // Ëá™ÂÆö‰πâËøûÁ∫øÊ∏≤Êüì
            renderNodesAndLinksCustom(descendants) {
                // Ê∏≤ÊüìËøûÊé•Á∫øÔºàÁà∂Â≠êÂÖ≥Á≥ªÔºâ
                const links = [];
                descendants.forEach(node => {
                    if (node.data && node.data.relations.parent) {
                        const parent = descendants.find(n => n.id === node.data.relations.parent);
                        if (parent) {
                            links.push({source: parent, target: node});
                        }
                    }
                });
                
                const link = this.linksGroup.selectAll('.link')
                    .data(links)
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y)
                    .attr('stroke', '#90a4ae')
                    .attr('stroke-width', 2);
                
                this.renderNodes(descendants);
            }

            // Ê∏≤ÊüìËäÇÁÇπ
            renderNodes(descendants) {
                const node = this.nodesGroup.selectAll('.node')
                    .data(descendants)
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this.selectNode(d.id || d.data.id);
                    })
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        this.editNode(d.id || d.data.id);
                    });
                
                // Ê∑ªÂä†ËäÇÁÇπÁü©ÂΩ¢
                node.append('rect')
                    .attr('width', d => Math.max(120, (d.title || d.data.title).length * 8 + 20))
                    .attr('height', 40)
                    .attr('x', d => -Math.max(60, (d.title || d.data.title).length * 4 + 10))
                    .attr('y', -20)
                    .attr('rx', 8)
                    .attr('ry', 8)
                    .attr('fill', d => (d.depth === 0 || (!d.data.relations.parent)) ? '#ff6b35' : '#4facfe')
                    .attr('stroke', d => (d.depth === 0 || (!d.data.relations.parent)) ? '#e55a2b' : '#0288d1')
                    .attr('stroke-width', 2);
                
                // Ê∑ªÂä†ËäÇÁÇπÊñáÊú¨
                node.append('text')
                    .text(d => {
                        const title = d.title || d.data.title;
                        return title.length > 15 ? title.substring(0, 15) + '...' : title;
                    })
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '14px')
                    .attr('font-weight', '500');
                
                // Ê∑ªÂä†ËäÇÁÇπÊèêÁ§∫
                node.append('title')
                    .text(d => {
                        const title = d.title || d.data.title;
                        const content = d.content || d.data.content;
                        return `${title}\n\n${content.substring(0, 100)}...\n\nÁÇπÂáªÈÄâÊã© | ÂèåÂáªÁºñËæë`;
                    });
                
                // Â≠òÂÇ®ËäÇÁÇπ‰ΩçÁΩÆ‰ø°ÊÅØ
                this.nodes.forEach(n => {
                    const treeNode = descendants.find(d => (d.id || d.data.id) === n.id);
                    if (treeNode) {
                        n.x = treeNode.x;
                        n.y = treeNode.y;
                    }
                });
            }

            // ËæÖÂä©ÊñπÊ≥ï
            groupByLevel() {
                const levels = {};
                const visited = new Set();
                
                const traverse = (nodeId, level = 0) => {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    if (!levels[level]) levels[level] = [];
                    levels[level].push(node);
                    
                    // ÊâæÂ≠êËäÇÁÇπ
                    const children = this.nodes.filter(n => n.data.relations.parent === nodeId);
                    children.forEach(child => traverse(child.id, level + 1));
                };
                
                const rootNodes = this.nodes.filter(n => !n.data.relations.parent);
                rootNodes.forEach(root => traverse(root.id));
                
                return levels;
            }

            getLevelCounts(hierarchy) {
                const counts = [];
                const traverse = (node, depth = 0) => {
                    counts[depth] = (counts[depth] || 0) + 1;
                    if (node.children) {
                        node.children.forEach(child => traverse(child, depth + 1));
                    }
                };
                traverse(hierarchy);
                return counts;
            }

            getMaxDepth(hierarchy) {
                const getDepth = (node) => {
                    if (!node.children) return 1;
                    return 1 + Math.max(...node.children.map(getDepth));
                };
                return getDepth(hierarchy);
            }

            adjustForCollisions(nodes) {
                for (let i = 0; i < 3; i++) { // Â§öÊ¨°Ëø≠‰ª£‰ºòÂåñ
                    nodes.forEach((node, idx) => {
                        nodes.slice(idx + 1).forEach(other => {
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDistance = 80;
                            
                            if (distance < minDistance && distance > 0) {
                                const pushX = (dx / distance) * (minDistance - distance) * 0.5;
                                const pushY = (dy / distance) * (minDistance - distance) * 0.5;
                                node.x += pushX;
                                node.y += pushY;
                                other.x -= pushX;
                                other.y -= pushY;
                            }
                        });
                    });
                }
            }

            buildHierarchy(root) {
                const addChildren = (node) => {
                    const children = this.nodes.filter(n => n.data.relations.parent === node.id);
                    if (children.length > 0) {
                        node.children = children.map(child => {
                            const childNode = {
                                id: child.id,
                                title: child.title,
                                content: child.content,
                                data: child.data
                            };
                            return addChildren(childNode);
                        });
                    }
                    return node;
                };
                
                return addChildren({
                    id: root.id,
                    title: root.title,
                    content: root.content,
                    data: root.data
                });
            }

            loadMarkdown(markdown) {
                const blocks = this.parseMarkdown(markdown);
                this.buildGraph(blocks);
                this.clear();
                this.render();
            }

            clear() {
                this.linksGroup.selectAll('*').remove();
                this.nodesGroup.selectAll('*').remove();
            }

            zoomIn() {
                this.svg.transition().call(this.zoom.scaleBy, 1.5);
            }

            zoomOut() {
                this.svg.transition().call(this.zoom.scaleBy, 1 / 1.5);
            }

            fitToView() {
                const bounds = this.container.node().getBBox();
                const parent = this.container.node().parentElement;
                const fullWidth = parent.clientWidth || parent.parentNode.clientWidth;
                const fullHeight = parent.clientHeight || parent.parentNode.clientHeight;
                
                if (bounds.width === 0 || bounds.height === 0) return;
                
                const midX = bounds.x + bounds.width / 2;
                const midY = bounds.y + bounds.height / 2;
                const scale = 0.8 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight);
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                
                this.svg.transition()
                    .duration(750)
                    .call(this.zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
            }

            exportData() {
                const data = {
                    nodes: this.nodes,
                    links: this.links,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mindmap-data.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            updateStatus() {
                const statusText = document.getElementById('status-text');
                const selectedInfo = this.selectedNode ? ` | Â∑≤ÈÄâÊã©: ${this.selectedNode}` : '';
                statusText.textContent = `Â∞±Áª™ | ËäÇÁÇπÊï∞: ${this.nodes.length} | ËøûÊé•Êï∞: ${this.links.length}${selectedInfo} | EnterÊ∑ªÂä†ÂêåÁ∫ßÔºåCtrl+EnterÊ∑ªÂä†Â≠êËäÇÁÇπ`;
            }
        }

        // ÂàùÂßãÂåñËÑëÂõæ
        const mindMap = new NodeMindMap('#mindmap-svg');

        // Á§∫‰æãÊï∞ÊçÆ
        const examples = {
            project: `ÁºñÂè∑Ôºö{#P001}
Ê†áÈ¢òÔºö‰∫ßÂìÅÂºÄÂèëÈ°πÁõÆ
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÈ°πÁõÆÁªèÁêÜ

‰∫ßÂìÅÂºÄÂèëÁöÑ‰∏ªË¶ÅÈ°πÁõÆÔºåÂåÖÂê´ÈúÄÊ±ÇÂàÜÊûê„ÄÅËÆæËÆ°„ÄÅÂºÄÂèë„ÄÅÊµãËØïÁ≠âÂêÑ‰∏™Èò∂ÊÆµ„ÄÇ

ÂÖ≥ÈîÆÁõÆÊ†áÔºö
- ÊåâÊó∂‰∫§‰ªòÈ´òË¥®Èáè‰∫ßÂìÅ
- Êª°Ë∂≥Áî®Êà∑ÈúÄÊ±Ç
- ÊéßÂà∂ÊàêÊú¨ÂíåÈ£éÈô©

---
„ÄêÊ†áËÆ∞Êóè„Äë
ÂàÜÁ±ªÊ†áÁ≠æÔºö@È°πÁõÆ.ÁÆ°ÁêÜ.ÂºÄÂèë
Áä∂ÊÄÅÊ†áÁ≠æÔºö@ËøõË°å‰∏≠

ÁºñÂè∑Ôºö{#P002}
Ê†áÈ¢òÔºöÈúÄÊ±ÇÂàÜÊûê
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºö‰∫ßÂìÅÁªèÁêÜ

Ê∑±ÂÖ•ÂàÜÊûêÁî®Êà∑ÈúÄÊ±ÇÔºåÂà∂ÂÆö‰∫ßÂìÅÂäüËÉΩËßÑÊ†º„ÄÇ

‰∏ªË¶ÅÂ∑•‰ΩúÔºö
- Áî®Êà∑Ë∞ÉÁ†î
- Á´ûÂìÅÂàÜÊûê
- ÂäüËÉΩÂÆö‰πâ

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^P001
ÂàÜÁ±ªÊ†áÁ≠æÔºö@È°πÁõÆ.ÈúÄÊ±Ç.ÂàÜÊûê
Áä∂ÊÄÅÊ†áÁ≠æÔºö@Â∑≤ÂÆåÊàê

ÁºñÂè∑Ôºö{#P003}
Ê†áÈ¢òÔºöÁ≥ªÁªüËÆæËÆ°
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÊû∂ÊûÑÂ∏à

Âü∫‰∫éÈúÄÊ±ÇÂàÜÊûêÁªìÊûúÔºåËÆæËÆ°Á≥ªÁªüÊû∂ÊûÑÂíåÊäÄÊúØÊñπÊ°à„ÄÇ

ËÆæËÆ°ÂÜÖÂÆπÔºö
- Á≥ªÁªüÊû∂ÊûÑ
- Êï∞ÊçÆÂ∫ìËÆæËÆ°
- Êé•Âè£ËÆæËÆ°

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^P001
‰æùËµñÂÖ≥Á≥ªÔºö‚ÜêP002
ÂàÜÁ±ªÊ†áÁ≠æÔºö@È°πÁõÆ.ËÆæËÆ°.Êû∂ÊûÑ
Áä∂ÊÄÅÊ†áÁ≠æÔºö@ËøõË°å‰∏≠`,

            knowledge: `ÁºñÂè∑Ôºö{#K001}
Ê†áÈ¢òÔºöÂâçÁ´ØÂºÄÂèëÁü•ËØÜ‰ΩìÁ≥ª
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÊäÄÊúØ‰∏ìÂÆ∂

ÂâçÁ´ØÂºÄÂèëÁöÑÂÆåÊï¥Áü•ËØÜ‰ΩìÁ≥ªÔºåÊ∂µÁõñÂü∫Á°ÄÁü•ËØÜÂà∞È´òÁ∫ßÂ∫îÁî®„ÄÇ

Ê†∏ÂøÉÈ¢ÜÂüüÔºö
- HTML/CSS/JavaScriptÂü∫Á°Ä
- Ê°ÜÊû∂‰∏éÂ∫ìÂ∫îÁî®
- Â∑•Á®ãÂåñ‰∏é‰ºòÂåñ

---
„ÄêÊ†áËÆ∞Êóè„Äë
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Áü•ËØÜ.ÂâçÁ´Ø.‰ΩìÁ≥ª
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.JavaScript.Ê°ÜÊû∂

ÁºñÂè∑Ôºö{#K002}
Ê†áÈ¢òÔºöJavaScriptÂü∫Á°Ä
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÊäÄÊúØ‰∏ìÂÆ∂

JavaScriptËØ≠Ë®ÄÁöÑÊ†∏ÂøÉÊ¶ÇÂøµÂíåÂü∫Á°ÄËØ≠Ê≥ï„ÄÇ

Â≠¶‰π†ÈáçÁÇπÔºö
- ÂèòÈáè‰∏éÊï∞ÊçÆÁ±ªÂûã
- ÂáΩÊï∞‰∏é‰ΩúÁî®Âüü
- ÂºÇÊ≠•ÁºñÁ®ã

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^K001
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Áü•ËØÜ.ÂâçÁ´Ø.Âü∫Á°Ä
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.JavaScript.ËØ≠Ê≥ï

ÁºñÂè∑Ôºö{#K003}
Ê†áÈ¢òÔºöReactÊ°ÜÊû∂
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÊäÄÊúØ‰∏ìÂÆ∂

ReactÊ°ÜÊû∂ÁöÑÊ†∏ÂøÉÊ¶ÇÂøµÂíåÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇ

Ê†∏ÂøÉÂÜÖÂÆπÔºö
- ÁªÑ‰ª∂ÂåñÂºÄÂèë
- Áä∂ÊÄÅÁÆ°ÁêÜ
- ÁîüÂëΩÂë®Êúü

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^K001
‰æùËµñÂÖ≥Á≥ªÔºö‚ÜêK002
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Áü•ËØÜ.ÂâçÁ´Ø.Ê°ÜÊû∂
ÊäÄÊúØÊ†áÁ≠æÔºö@ÂâçÁ´Ø.React.ÁªÑ‰ª∂`,

            learning: `ÁºñÂè∑Ôºö{#L001}
Ê†áÈ¢òÔºöÊï∞ÊçÆÁªìÊûÑ‰∏éÁÆóÊ≥ï
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂ≠¶‰π†ËÄÖ

ËÆ°ÁÆóÊú∫ÁßëÂ≠¶ÁöÑÊ†∏ÂøÉËØæÁ®ãÔºåÂ≠¶‰π†ÂêÑÁßçÊï∞ÊçÆÁªìÊûÑÂíåÁÆóÊ≥ï„ÄÇ

Â≠¶‰π†ÁõÆÊ†áÔºö
- ÊéåÊè°Âü∫Êú¨Êï∞ÊçÆÁªìÊûÑ
- ÁêÜËß£ÁÆóÊ≥ïÂ§çÊùÇÂ∫¶
- ÂüπÂÖªÁºñÁ®ãÊÄùÁª¥

---
„ÄêÊ†áËÆ∞Êóè„Äë
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Â≠¶‰π†.ËÆ°ÁÆóÊú∫.Âü∫Á°Ä
Áä∂ÊÄÅÊ†áÁ≠æÔºö@Â≠¶‰π†‰∏≠

ÁºñÂè∑Ôºö{#L002}
Ê†áÈ¢òÔºöÁ∫øÊÄßÊï∞ÊçÆÁªìÊûÑ
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂ≠¶‰π†ËÄÖ

Êï∞ÁªÑ„ÄÅÈìæË°®„ÄÅÊ†à„ÄÅÈòüÂàóÁ≠âÁ∫øÊÄßÊï∞ÊçÆÁªìÊûÑ„ÄÇ

‰∏ªË¶ÅÂÜÖÂÆπÔºö
- Êï∞ÁªÑÊìç‰Ωú
- ÈìæË°®ÂÆûÁé∞
- Ê†àÂíåÈòüÂàóÂ∫îÁî®

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^L001
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Â≠¶‰π†.Êï∞ÊçÆÁªìÊûÑ.Á∫øÊÄß
Áä∂ÊÄÅÊ†áÁ≠æÔºö@Â∑≤ÊéåÊè°

ÁºñÂè∑Ôºö{#L003}
Ê†áÈ¢òÔºöÊ†ëÂΩ¢Êï∞ÊçÆÁªìÊûÑ
Êó∂Èó¥Ôºö2025-01-17 | 2025-01-17
‰ΩúËÄÖÔºöÂ≠¶‰π†ËÄÖ

‰∫åÂèâÊ†ë„ÄÅÂπ≥Ë°°Ê†ë„ÄÅBÊ†ëÁ≠âÊ†ëÂΩ¢ÁªìÊûÑ„ÄÇ

ÈáçÁÇπÊ¶ÇÂøµÔºö
- ‰∫åÂèâÊ†ëÈÅçÂéÜ
- Âπ≥Ë°°Ê†ëÂéüÁêÜ
- Ê†ëÁöÑÂ∫îÁî®Âú∫ÊôØ

---
„ÄêÊ†áËÆ∞Êóè„Äë
Áà∂Â≠êÂÖ≥Á≥ªÔºö^L001
‰æùËµñÂÖ≥Á≥ªÔºö‚ÜêL002
ÂàÜÁ±ªÊ†áÁ≠æÔºö@Â≠¶‰π†.Êï∞ÊçÆÁªìÊûÑ.Ê†ëÂΩ¢
Áä∂ÊÄÅÊ†áÁ≠æÔºö@Â≠¶‰π†‰∏≠`
        };

        // Âä†ËΩΩÁ§∫‰æã
        function loadExample(type) {
            document.getElementById('markdown-input').value = examples[type];
            updateMindMap();
        }

        // Êõ¥Êñ∞ËÑëÂõæ
        function updateMindMap() {
            const markdown = document.getElementById('markdown-input').value;
            if (markdown.trim()) {
                mindMap.loadMarkdown(markdown);
            }
        }

        // Êõ¥Êñ∞Â∏ÉÂ±Ä
        function updateLayout() {
            updateMindMap();
        }

        // ÂàùÂßãÂåñÂä†ËΩΩ
        window.addEventListener('load', () => {
            updateMindMap();
        });

        // ÂÖ®Â±ÄÂáΩÊï∞‰æõHTMLË∞ÉÁî®
        function saveNodeContent() {
            mindMap.saveNodeContent();
        }

        function cancelNodeEdit() {
            mindMap.cancelNodeEdit();
        }
    </script>
</body>
</html> 