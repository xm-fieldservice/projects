<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeMind è„‘å›¾ç»„ä»¶</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .main-content {
            display: flex;
            height: calc(100vh - 140px);
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-bottom: 15px;
            color: #495057;
            font-size: 16px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        .textarea {
            width: 100%;
            min-height: 350px;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }

        .node-content-editor {
            margin-top: 15px;
            padding: 15px;
            border: 2px solid #ff6b35;
            border-radius: 8px;
            background: #fff8f5;
        }

        .node-content-editor h4 {
            margin: 0 0 10px 0;
            color: #ff6b35;
            font-size: 14px;
        }

        .node-content-editor textarea {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .node-content-editor .btn-group {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .node-content-editor .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-save:hover {
            background: #218838;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
        }

        .btn-cancel:hover {
            background: #5a6268;
        }

        .mindmap-container {
            flex: 1;
            position: relative;
            background: white;
        }

        .mindmap-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .mindmap-svg:active {
            cursor: grabbing;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node rect {
            fill: #4facfe;
            stroke: #0288d1;
            stroke-width: 2;
            rx: 8;
            ry: 8;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .node:hover rect {
            fill: #29b6f6;
            stroke: #0277bd;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.15));
        }

        .node.selected rect {
            fill: #ff6b35;
            stroke: #e55a2b;
            stroke-width: 3;
            filter: drop-shadow(0 4px 12px rgba(255,107,53,0.3));
        }

        .node text {
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            font-size: 14px;
            font-weight: 500;
            pointer-events: none;
        }

        .node-editor {
            position: absolute;
            background: white;
            border: 2px solid #4facfe;
            border-radius: 6px;
            padding: 8px;
            min-width: 120px;
            font-size: 14px;
            font-family: inherit;
            text-align: center;
            outline: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
        }

        .link {
            fill: none;
            stroke: #90a4ae;
            stroke-width: 2;
            opacity: 0.8;
        }

        .relationship-link {
            fill: none;
            stroke-width: 2;
            opacity: 0.7;
            stroke-dasharray: 5,5;
        }

        .relationship-link.reference {
            stroke: #ff7043;
        }

        .relationship-link.dependency {
            stroke: #ab47bc;
        }

        .relationship-link.association {
            stroke: #26a69a;
        }

        .status-bar {
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            padding: 10px 20px;
            font-size: 12px;
            color: #6c757d;
        }

        .example-data {
            margin-bottom: 15px;
        }

        .example-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .example-btn:hover {
            background: #138496;
        }

        .zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #495057;
        }

        .zoom-btn:hover {
            background: #f8f9fa;
        }

        .shortcuts-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .shortcuts-info h4 {
            margin-bottom: 8px;
            color: #1976d2;
        }

        .shortcuts-info ul {
            margin: 0;
            padding-left: 16px;
        }

        .shortcuts-info li {
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§  NodeMind è„‘å›¾ç»„ä»¶</h1>
            <div class="controls">
                <button class="btn btn-primary" onclick="mindMap.fitToView()">é€‚åº”è§†å›¾</button>
                <button class="btn btn-primary" onclick="mindMap.exportData()">å¯¼å‡ºæ•°æ®</button>
                <button class="btn btn-primary" onclick="location.reload()">é‡ç½®</button>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>ğŸ“ Markdown è¾“å…¥</h3>
                
                <div class="shortcuts-info">
                    <h4>âŒ¨ï¸ å¿«æ·é”®æ“ä½œ</h4>
                    <ul>
                        <li><strong>Enter</strong>ï¼šæ·»åŠ åŒçº§èŠ‚ç‚¹</li>
                        <li><strong>Ctrl+Enter</strong>ï¼šæ·»åŠ å­èŠ‚ç‚¹</li>
                        <li><strong>åŒå‡»</strong>ï¼šç¼–è¾‘èŠ‚ç‚¹æ–‡æœ¬</li>
                        <li><strong>Del</strong>ï¼šåˆ é™¤é€‰ä¸­èŠ‚ç‚¹</li>
                        <li><strong>Esc</strong>ï¼šå–æ¶ˆé€‰æ‹©</li>
                    </ul>
                </div>
                
                <div class="example-data">
                    <button class="example-btn" onclick="loadExample('project')">é¡¹ç›®ç®¡ç†</button>
                    <button class="example-btn" onclick="loadExample('knowledge')">çŸ¥è¯†ä½“ç³»</button>
                    <button class="example-btn" onclick="loadExample('learning')">å­¦ä¹ ç¬”è®°</button>
                </div>

                <div class="input-group">
                    <label for="markdown-input">MDæ–‡æ¡£å†…å®¹ï¼š</label>
                    <textarea id="markdown-input" class="textarea" 
                              placeholder="è¾“å…¥ç¬¦åˆç¬”è®°å—æ ¼å¼çš„Markdownå†…å®¹..."
                              oninput="updateMindMap()">ç¼–å·ï¼š{#N001}
æ ‡é¢˜ï¼šNodeMind è„‘å›¾ç³»ç»Ÿ
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå¼€å‘å›¢é˜Ÿ

è¿™æ˜¯NodeMindè„‘å›¾ç³»ç»Ÿçš„æ ¸å¿ƒæ¨¡å—ï¼Œè´Ÿè´£å¤„ç†ç¬”è®°å—çš„å¯è§†åŒ–å±•ç¤ºã€‚

ä¸»è¦åŠŸèƒ½ï¼š
- è§£æMDæ–‡æ¡£ä¸­çš„ç¬”è®°å—
- æ„å»ºèŠ‚ç‚¹å…³ç³»å›¾
- æä¾›äº¤äº’å¼ç¼–è¾‘åŠŸèƒ½

---
ã€æ ‡è®°æ—ã€‘
åˆ†ç±»æ ‡ç­¾ï¼š@ç³»ç»Ÿ.æ ¸å¿ƒ.å¯è§†åŒ–
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.JavaScript.D3
çŠ¶æ€æ ‡ç­¾ï¼š@å¼€å‘ä¸­

ç¼–å·ï¼š{#N002}
æ ‡é¢˜ï¼šæ•°æ®è§£æå¼•æ“
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå¼€å‘å›¢é˜Ÿ

è´Ÿè´£è§£æMarkdownæ–‡æ¡£ï¼Œæå–ç¬”è®°å—å’Œå…³ç³»ä¿¡æ¯ã€‚

æ ¸å¿ƒèƒ½åŠ›ï¼š
- ç¬”è®°å—æå–
- å…³ç³»ç¬¦å·è§£æ
- æ ‡è®°æ—è§£æ

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^N001
åˆ†ç±»æ ‡ç­¾ï¼š@ç³»ç»Ÿ.æ ¸å¿ƒ.è§£æ
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.JavaScript.æ­£åˆ™è¡¨è¾¾å¼

ç¼–å·ï¼š{#N003}
æ ‡é¢˜ï¼šæ¸²æŸ“å¼•æ“
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå¼€å‘å›¢é˜Ÿ

åŸºäºD3.jsçš„å›¾å½¢æ¸²æŸ“å¼•æ“ï¼Œè´Ÿè´£è„‘å›¾çš„å¯è§†åŒ–å±•ç¤ºã€‚

ä¸»è¦ç‰¹æ€§ï¼š
- åŠ¨æ€å¸ƒå±€ç®—æ³•
- èŠ‚ç‚¹äº¤äº’æ§åˆ¶
- å…³ç³»çº¿æ¸²æŸ“

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^N001
ä¾èµ–å…³ç³»ï¼šâ†N002
åˆ†ç±»æ ‡ç­¾ï¼š@ç³»ç»Ÿ.æ ¸å¿ƒ.æ¸²æŸ“
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.D3js.SVG</textarea>
                </div>

                <!-- èŠ‚ç‚¹å†…å®¹ç¼–è¾‘å™¨ -->
                <div id="node-content-editor" class="node-content-editor" style="display: none;">
                    <h4>ğŸ“ ç¼–è¾‘èŠ‚ç‚¹å†…å®¹</h4>
                    <div>
                        <strong>èŠ‚ç‚¹IDï¼š</strong><span id="editing-node-id">æ— </span>
                    </div>
                    <div style="margin-top: 8px;">
                        <strong>èŠ‚ç‚¹æ ‡é¢˜ï¼š</strong><span id="editing-node-title">æ— </span>
                    </div>
                    <textarea id="node-content-textarea" placeholder="ç¼–è¾‘èŠ‚ç‚¹çš„è¯¦ç»†å†…å®¹..."></textarea>
                    <div class="btn-group">
                        <button class="btn-small btn-save" onclick="saveNodeContent()">ä¿å­˜</button>
                        <button class="btn-small btn-cancel" onclick="cancelNodeEdit()">å–æ¶ˆ</button>
                    </div>
                </div>

                <div class="input-group">
                    <label>å¸ƒå±€ç®—æ³•ï¼š</label>
                    <select id="layout-select" onchange="updateLayout()">
                        <option value="horizontal">æ ‡å‡†æ°´å¹³æ ‘</option>
                        <option value="vertical">å‚ç›´æ ‘å¸ƒå±€</option>
                        <option value="radial">å¾„å‘è¾å°„å¸ƒå±€</option>
                        <option value="circle">åœ†å½¢åˆ†å±‚å¸ƒå±€</option>
                        <option value="compact">ç´§å‡‘è‡ªé€‚åº”å¸ƒå±€</option>
                        <option value="fishbone">é±¼éª¨äº¤æ›¿å¸ƒå±€</option>
                    </select>
                </div>
            </div>

            <div class="mindmap-container">
                <svg id="mindmap-svg" class="mindmap-svg"></svg>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="mindMap.zoomIn()">+</button>
                    <button class="zoom-btn" onclick="mindMap.zoomOut()">-</button>
                    <button class="zoom-btn" onclick="mindMap.fitToView()">âŒ‚</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="status-text">å‡†å¤‡å°±ç»ª | èŠ‚ç‚¹æ•°: 0 | å…³ç³»æ•°: 0 | æ“ä½œæç¤ºï¼šç‚¹å‡»èŠ‚ç‚¹é€‰æ‹©ï¼ŒEnteræ·»åŠ åŒçº§ï¼ŒCtrl+Enteræ·»åŠ å­èŠ‚ç‚¹</span>
        </div>
    </div>

    <script>
        class NodeMindMap {
            constructor(svgSelector) {
                this.svg = d3.select(svgSelector);
                this.width = 1000;
                this.height = 600;
                this.data = null;
                this.nodes = [];
                this.links = [];
                this.simulation = null;
                this.transform = d3.zoomIdentity;
                this.selectedNode = null;
                this.editingNode = null;
                this.editingNodeContent = null;
                this.nextNodeId = 4; // ä»N004å¼€å§‹
                
                this.init();
                this.setupKeyboardEvents();
            }

            init() {
                this.svg.attr('viewBox', `0 0 ${this.width} ${this.height}`);
                
                // æ·»åŠ ç¼©æ”¾åŠŸèƒ½
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.transform = event.transform;
                        this.container.attr('transform', this.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // åˆ›å»ºå®¹å™¨ç»„
                this.container = this.svg.append('g');
                this.linksGroup = this.container.append('g').attr('class', 'links');
                this.nodesGroup = this.container.append('g').attr('class', 'nodes');

                // ç‚¹å‡»ç©ºç™½å¤„å–æ¶ˆé€‰æ‹©
                this.svg.on('click', (event) => {
                    if (event.target === event.currentTarget) {
                        this.selectNode(null);
                    }
                });
            }

            setupKeyboardEvents() {
                document.addEventListener('keydown', (event) => {
                    // å¦‚æœåœ¨ç¼–è¾‘çŠ¶æ€ï¼Œä¸å¤„ç†å¿«æ·é”®
                    if (this.editingNode) return;
                    
                    switch(event.key) {
                        case 'Enter':
                            event.preventDefault();
                            if (event.ctrlKey) {
                                this.addChildNode();
                            } else {
                                this.addSiblingNode();
                            }
                            break;
                        case 'Delete':
                        case 'Backspace':
                            event.preventDefault();
                            this.deleteSelectedNode();
                            break;
                        case 'Escape':
                            this.selectNode(null);
                            break;
                    }
                });
            }

            selectNode(nodeId) {
                // ç§»é™¤ä¹‹å‰çš„é€‰æ‹©çŠ¶æ€
                this.nodesGroup.selectAll('.node').classed('selected', false);
                
                if (nodeId) {
                    // æ·»åŠ æ–°çš„é€‰æ‹©çŠ¶æ€
                    this.nodesGroup.selectAll('.node')
                        .filter(d => (d.id || d.data.id) === nodeId)
                        .classed('selected', true);
                    this.selectedNode = nodeId;
                    
                    // æ˜¾ç¤ºèŠ‚ç‚¹å†…å®¹ç¼–è¾‘å™¨
                    this.showNodeEditor(nodeId);
                } else {
                    this.selectedNode = null;
                    this.hideNodeEditor();
                }
                
                this.updateStatus();
            }

            showNodeEditor(nodeId) {
                const nodeData = this.nodes.find(n => n.id === nodeId);
                if (!nodeData) return;

                const editor = document.getElementById('node-content-editor');
                const nodeIdSpan = document.getElementById('editing-node-id');
                const nodeTitleSpan = document.getElementById('editing-node-title');
                const textarea = document.getElementById('node-content-textarea');

                nodeIdSpan.textContent = nodeData.id;
                nodeTitleSpan.textContent = nodeData.title;
                textarea.value = this.extractNodeContent(nodeData);
                
                editor.style.display = 'block';
                this.editingNodeContent = nodeId;
            }

            hideNodeEditor() {
                const editor = document.getElementById('node-content-editor');
                editor.style.display = 'none';
                this.editingNodeContent = null;
            }

            extractNodeContent(nodeData) {
                // ä»MDæ–‡æ¡£ä¸­æå–è¯¥èŠ‚ç‚¹çš„å®Œæ•´å†…å®¹
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // æŸ¥æ‰¾è¯¥èŠ‚ç‚¹çš„å®Œæ•´å—
                const nodePattern = new RegExp(`ç¼–å·ï¼š\\{#${nodeData.id}\\}[\\s\\S]*?(?=ç¼–å·ï¼š\\{#|$)`, 'g');
                const match = nodePattern.exec(content);
                
                if (match) {
                    return match[0].trim();
                } else {
                    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›åŸºæœ¬æ ¼å¼
                    return `ç¼–å·ï¼š{#${nodeData.id}}
æ ‡é¢˜ï¼š${nodeData.title}
æ—¶é—´ï¼š${nodeData.time}
ä½œè€…ï¼š${nodeData.author}

${nodeData.content}

---
ã€æ ‡è®°æ—ã€‘
${nodeData.data.relations.parent ? `çˆ¶å­å…³ç³»ï¼š^${nodeData.data.relations.parent}\n` : ''}åˆ†ç±»æ ‡ç­¾ï¼š@${nodeData.data.tags.categories.join('.')}
${nodeData.data.tags.technical.length > 0 ? `æŠ€æœ¯æ ‡ç­¾ï¼š@${nodeData.data.tags.technical.join('.')}\n` : ''}${nodeData.data.tags.status.length > 0 ? `çŠ¶æ€æ ‡ç­¾ï¼š@${nodeData.data.tags.status.join('.')}` : ''}`;
                }
            }

            saveNodeContent() {
                if (!this.editingNodeContent) return;

                const textarea = document.getElementById('node-content-textarea');
                const newContent = textarea.value.trim();
                
                if (!newContent) {
                    alert('å†…å®¹ä¸èƒ½ä¸ºç©º');
                    return;
                }

                // æ›´æ–°MDæ–‡æ¡£
                this.updateNodeInMarkdown(this.editingNodeContent, newContent);
                
                // é‡æ–°åŠ è½½è„‘å›¾
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // é‡æ–°é€‰æ‹©è¯¥èŠ‚ç‚¹
                setTimeout(() => {
                    this.selectNode(this.editingNodeContent);
                }, 100);

                alert('èŠ‚ç‚¹å†…å®¹å·²ä¿å­˜');
            }

            cancelNodeEdit() {
                this.hideNodeEditor();
                this.selectNode(null);
            }

            updateNodeInMarkdown(nodeId, newContent) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // æ›¿æ¢è¯¥èŠ‚ç‚¹çš„å†…å®¹
                const nodePattern = new RegExp(`ç¼–å·ï¼š\\{#${nodeId}\\}[\\s\\S]*?(?=ç¼–å·ï¼š\\{#|$)`, 'g');
                const newMarkdown = content.replace(nodePattern, newContent + '\n\n');
                
                textarea.value = newMarkdown.trim();
            }

            addSiblingNode() {
                if (!this.selectedNode) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹');
                    return;
                }

                const selectedNodeData = this.nodes.find(n => n.id === this.selectedNode);
                if (!selectedNodeData) return;

                const newId = `N${String(this.nextNodeId++).padStart(3, '0')}`;
                const newTitle = `æ–°èŠ‚ç‚¹ ${newId}`;
                
                // æ·»åŠ åˆ°MDæ–‡æ¡£
                this.addNodeToMarkdown(newId, newTitle, selectedNodeData.data.relations.parent);
                
                // åˆ·æ–°è„‘å›¾
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // é€‰æ‹©æ–°èŠ‚ç‚¹
                setTimeout(() => {
                    this.selectNode(newId);
                    this.editNode(newId);
                }, 100);
            }

            addChildNode() {
                if (!this.selectedNode) {
                    alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹');
                    return;
                }

                const newId = `N${String(this.nextNodeId++).padStart(3, '0')}`;
                const newTitle = `å­èŠ‚ç‚¹ ${newId}`;
                
                // æ·»åŠ åˆ°MDæ–‡æ¡£ï¼Œçˆ¶èŠ‚ç‚¹æ˜¯å½“å‰é€‰ä¸­çš„èŠ‚ç‚¹
                this.addNodeToMarkdown(newId, newTitle, this.selectedNode);
                
                // åˆ·æ–°è„‘å›¾
                this.loadMarkdown(document.getElementById('markdown-input').value);
                
                // é€‰æ‹©æ–°èŠ‚ç‚¹
                setTimeout(() => {
                    this.selectNode(newId);
                    this.editNode(newId);
                }, 100);
            }

            addNodeToMarkdown(id, title, parentId = null) {
                const textarea = document.getElementById('markdown-input');
                const currentContent = textarea.value;
                
                const newNodeContent = `

ç¼–å·ï¼š{#${id}}
æ ‡é¢˜ï¼š${title}
æ—¶é—´ï¼š${new Date().toISOString().split('T')[0]} | ${new Date().toISOString().split('T')[0]}
ä½œè€…ï¼šç”¨æˆ·

æ–°èŠ‚ç‚¹å†…å®¹...

ä¸»è¦åŠŸèƒ½ï¼š
- åŠŸèƒ½æè¿°1
- åŠŸèƒ½æè¿°2

---
ã€æ ‡è®°æ—ã€‘${parentId ? `
çˆ¶å­å…³ç³»ï¼š^${parentId}` : ''}
åˆ†ç±»æ ‡ç­¾ï¼š@æ–°å»º.èŠ‚ç‚¹
çŠ¶æ€æ ‡ç­¾ï¼š@ç¼–è¾‘ä¸­`;

                textarea.value = currentContent + newNodeContent;
            }

            deleteSelectedNode() {
                if (!this.selectedNode) {
                    alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„èŠ‚ç‚¹');
                    return;
                }

                if (confirm(`ç¡®å®šè¦åˆ é™¤èŠ‚ç‚¹ "${this.selectedNode}" å—ï¼Ÿ`)) {
                    this.removeNodeFromMarkdown(this.selectedNode);
                    this.loadMarkdown(document.getElementById('markdown-input').value);
                    this.selectNode(null);
                }
            }

            removeNodeFromMarkdown(nodeId) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ é™¤æŒ‡å®šèŠ‚ç‚¹
                const nodePattern = new RegExp(`ç¼–å·ï¼š\\{#${nodeId}\\}[\\s\\S]*?(?=ç¼–å·ï¼š\\{#|$)`, 'g');
                const newContent = content.replace(nodePattern, '').trim();
                
                textarea.value = newContent;
            }

            editNode(nodeId) {
                const nodeElement = this.nodesGroup.selectAll('.node')
                    .filter(d => d.id === nodeId);
                
                if (nodeElement.empty()) return;

                const nodeData = nodeElement.datum();
                const rect = nodeElement.select('rect').node();
                const rectBBox = rect.getBBox();
                const transform = nodeElement.attr('transform');
                
                // è§£ætransformå±æ€§è·å–ä½ç½®
                const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                if (!translateMatch) return;
                
                const x = parseFloat(translateMatch[1]);
                const y = parseFloat(translateMatch[2]);
                
                // åˆ›å»ºç¼–è¾‘è¾“å…¥æ¡†
                const editor = document.createElement('input');
                editor.className = 'node-editor';
                editor.value = nodeData.title;
                editor.style.left = (x + rectBBox.x) + 'px';
                editor.style.top = (y + rectBBox.y - 5) + 'px';
                editor.style.width = Math.max(120, rectBBox.width) + 'px';
                
                document.querySelector('.mindmap-container').appendChild(editor);
                
                this.editingNode = nodeId;
                editor.focus();
                editor.select();
                
                const finishEditing = () => {
                    const newTitle = editor.value.trim() || nodeData.title;
                    this.updateNodeTitle(nodeId, newTitle);
                    editor.remove();
                    this.editingNode = null;
                };
                
                editor.addEventListener('blur', finishEditing);
                editor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEditing();
                    } else if (e.key === 'Escape') {
                        editor.remove();
                        this.editingNode = null;
                    }
                });
            }

            updateNodeTitle(nodeId, newTitle) {
                const textarea = document.getElementById('markdown-input');
                const content = textarea.value;
                
                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›´æ–°èŠ‚ç‚¹æ ‡é¢˜
                const titlePattern = new RegExp(`(ç¼–å·ï¼š\\{#${nodeId}\\}\\s*\\næ ‡é¢˜ï¼š)[^\\n]+`, 'g');
                const newContent = content.replace(titlePattern, `$1${newTitle}`);
                
                textarea.value = newContent;
                this.loadMarkdown(newContent);
            }

            parseMarkdown(markdown) {
                const blocks = [];
                
                // å…ˆæŒ‰ç¼–å·åˆ†å‰²æ–‡æ¡£
                const sections = markdown.split(/(?=ç¼–å·ï¼š\{#[^}]+\})/);
                
                sections.forEach(section => {
                    if (!section.trim()) return;
                    
                    // è§£ææ¯ä¸ªsection
                    const headerMatch = section.match(/ç¼–å·ï¼š\{#([^}]+)\}\s*\næ ‡é¢˜ï¼š([^\n]+)\s*\næ—¶é—´ï¼š([^\n]+)\s*\nä½œè€…ï¼š([^\n]+)\s*\n([\s\S]*?)(?=---\s*ã€æ ‡è®°æ—ã€‘|$)/);
                    
                    if (!headerMatch) return;
                    
                    const [, id, title, time, author, content] = headerMatch;
                    
                    const block = {
                        id: id.trim(),
                        title: title.trim(),
                        time: time.trim(),
                        author: author.trim(),
                        content: content.trim(),
                        relations: {
                            parent: null,
                            references: [],
                            dependencies: [],
                            associations: []
                        },
                        tags: {
                            categories: [],
                            technical: [],
                            status: []
                        }
                    };
                    
                    // è§£æå…³ç³»æ ‡è®°
                    const relationMatch = section.match(/---\s*ã€æ ‡è®°æ—ã€‘\s*([\s\S]*?)(?=ç¼–å·ï¼š\{#|$)/);
                    
                    if (relationMatch) {
                        const relationText = relationMatch[1];
                        
                        // è§£æå„ç§å…³ç³»
                        const parentMatch = relationText.match(/çˆ¶å­å…³ç³»ï¼š\^([^\s\n]+)/);
                        if (parentMatch) {
                            block.relations.parent = parentMatch[1];
                        }
                        
                        const refMatches = relationText.match(/å¼•ç”¨å…³ç³»ï¼š((?:â†’[^\s\n]+\s*)+)/);
                        if (refMatches) {
                            block.relations.references = refMatches[1].match(/â†’([^\s\n]+)/g)?.map(r => r.slice(1)) || [];
                        }
                        
                        const depMatches = relationText.match(/ä¾èµ–å…³ç³»ï¼š((?:â†[^\s\n]+\s*)+)/);
                        if (depMatches) {
                            block.relations.dependencies = depMatches[1].match(/â†([^\s\n]+)/g)?.map(d => d.slice(1)) || [];
                        }
                        
                        // è§£ææ ‡ç­¾
                        const categoryMatches = relationText.match(/åˆ†ç±»æ ‡ç­¾ï¼š@([^\n]+)/);
                        if (categoryMatches) {
                            block.tags.categories = categoryMatches[1].split('.').map(t => t.trim());
                        }
                        
                        const techMatches = relationText.match(/æŠ€æœ¯æ ‡ç­¾ï¼š@([^\n]+)/);
                        if (techMatches) {
                            block.tags.technical = techMatches[1].split('.').map(t => t.trim());
                        }
                        
                        const statusMatches = relationText.match(/çŠ¶æ€æ ‡ç­¾ï¼š@([^\n]+)/);
                        if (statusMatches) {
                            block.tags.status = statusMatches[1].split('.').map(t => t.trim());
                        }
                    }
                    
                    blocks.push(block);
                });
                
                // æ›´æ–°nextNodeId
                blocks.forEach(block => {
                    const idNum = parseInt(block.id.replace(/\D/g, ''));
                    if (idNum >= this.nextNodeId) {
                        this.nextNodeId = idNum + 1;
                    }
                });
                
                return blocks;
            }

            buildGraph(blocks) {
                // æ„å»ºèŠ‚ç‚¹
                this.nodes = blocks.map(block => ({
                    id: block.id,
                    title: block.title,
                    content: block.content,
                    data: block,
                    x: Math.random() * this.width,
                    y: Math.random() * this.height
                }));
                
                // æ„å»ºè¿æ¥
                this.links = [];
                
                blocks.forEach(block => {
                    // çˆ¶å­å…³ç³»
                    if (block.relations.parent) {
                        this.links.push({
                            source: block.relations.parent,
                            target: block.id,
                            type: 'hierarchy'
                        });
                    }
                    
                    // å¼•ç”¨å…³ç³»
                    block.relations.references.forEach(ref => {
                        this.links.push({
                            source: block.id,
                            target: ref,
                            type: 'reference'
                        });
                    });
                    
                    // ä¾èµ–å…³ç³»
                    block.relations.dependencies.forEach(dep => {
                        this.links.push({
                            source: dep,
                            target: block.id,
                            type: 'dependency'
                        });
                    });
                });
                
                // æ›´æ–°çŠ¶æ€
                this.updateStatus();
            }

            render() {
                const rootNodes = this.nodes.filter(n => !n.data.relations.parent);
                if (rootNodes.length === 0) return;
                
                const root = rootNodes[0];
                const layoutType = document.getElementById('layout-select').value;
                
                // æ ¹æ®é€‰æ‹©çš„å¸ƒå±€ç±»å‹è°ƒç”¨ä¸åŒçš„å¸ƒå±€ç®—æ³•
                switch(layoutType) {
                    case 'horizontal':
                        this.renderHorizontalTree(root);
                        break;
                    case 'vertical':
                        this.renderVerticalTree(root);
                        break;
                    case 'radial':
                        this.renderRadialLayout(root);
                        break;
                    case 'circle':
                        this.renderCircleLayout(root);
                        break;
                    case 'compact':
                        this.renderCompactLayout(root);
                        break;
                    case 'fishbone':
                        this.renderFishboneLayout(root);
                        break;
                    default:
                        this.renderHorizontalTree(root);
                }
            }

            // 1. æ ‡å‡†æ°´å¹³æ ‘å¸ƒå±€
            renderHorizontalTree(root) {
                const hierarchy = this.buildHierarchy(root);
                const treeLayout = d3.tree()
                    .size([this.height - 100, this.width - 200])
                    .separation((a, b) => (a.parent === b.parent ? 1.5 : 2.5) / a.depth);
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const temp = d.x;
                    d.x = d.y + 100;
                    d.y = temp + 50;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 2. å‚ç›´æ ‘å¸ƒå±€
            renderVerticalTree(root) {
                const hierarchy = this.buildHierarchy(root);
                const treeLayout = d3.tree()
                    .size([this.width - 200, this.height - 100])
                    .separation((a, b) => (a.parent === b.parent ? 1.2 : 2) / a.depth);
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    d.x = d.x + 100;
                    d.y = d.y + 50;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 3. å¾„å‘è¾å°„å¸ƒå±€
            renderRadialLayout(root) {
                const hierarchy = this.buildHierarchy(root);
                const radius = Math.min(this.width, this.height) / 2 - 100;
                const tree = d3.cluster().size([2 * Math.PI, radius]);
                
                const treeRoot = d3.hierarchy(hierarchy);
                tree(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const angle = d.x;
                    const r = d.y;
                    d.x = Math.cos(angle - Math.PI / 2) * r + this.width / 2;
                    d.y = Math.sin(angle - Math.PI / 2) * r + this.height / 2;
                });
                
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 4. åœ†å½¢åˆ†å±‚å¸ƒå±€
            renderCircleLayout(root) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                
                // æŒ‰å±‚çº§åˆ†ç»„
                const levels = this.groupByLevel();
                const descendants = [];
                
                Object.keys(levels).forEach(levelStr => {
                    const level = parseInt(levelStr);
                    const nodes = levels[level];
                    
                    if (level === 0) {
                        // æ ¹èŠ‚ç‚¹å±…ä¸­
                        nodes[0].x = centerX;
                        nodes[0].y = centerY;
                        descendants.push(nodes[0]);
                    } else {
                        // å…¶ä»–å±‚çº§å›´ç»•ä¸­å¿ƒåœ†å½¢åˆ†å¸ƒ
                        const radius = level * 120;
                        const angleStep = (2 * Math.PI) / nodes.length;
                        
                        nodes.forEach((node, i) => {
                            const angle = i * angleStep;
                            node.x = centerX + Math.cos(angle) * radius;
                            node.y = centerY + Math.sin(angle) * radius;
                            descendants.push(node);
                        });
                    }
                });
                
                this.renderNodesAndLinksCustom(descendants);
            }

            // 5. ç´§å‡‘è‡ªé€‚åº”å¸ƒå±€
            renderCompactLayout(root) {
                const hierarchy = this.buildHierarchy(root);
                
                // åŠ¨æ€è®¡ç®—å°ºå¯¸
                const maxNodes = Math.max(...this.getLevelCounts(hierarchy));
                const dynamicWidth = Math.max(this.width, maxNodes * 140);
                const dynamicHeight = Math.max(this.height, this.getMaxDepth(hierarchy) * 80);
                
                const treeLayout = d3.tree()
                    .size([dynamicHeight - 100, dynamicWidth - 200])
                    .separation((a, b) => {
                        const baseDistance = a.parent === b.parent ? 1.2 : 2;
                        const nodeCountFactor = a.parent ? Math.max(1, a.parent.children.length / 8) : 1;
                        return baseDistance * nodeCountFactor;
                    });
                
                const treeRoot = d3.hierarchy(hierarchy);
                treeLayout(treeRoot);
                
                const descendants = treeRoot.descendants();
                descendants.forEach(d => {
                    const temp = d.x;
                    d.x = d.y + 100;
                    d.y = temp + 50;
                });
                
                // ç¢°æ’æ£€æµ‹å’Œè°ƒæ•´
                this.adjustForCollisions(descendants);
                this.renderNodesAndLinks(descendants, treeRoot.links());
            }

            // 6. é±¼éª¨äº¤æ›¿å¸ƒå±€
            renderFishboneLayout(root) {
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const descendants = [];
                
                // æ ¹èŠ‚ç‚¹å±…ä¸­
                root.x = centerX;
                root.y = centerY;
                descendants.push(root);
                
                // è·å–å­èŠ‚ç‚¹å¹¶æŒ‰å±‚çº§åˆ†å¸ƒ
                const children = this.nodes.filter(n => n.data.relations.parent === root.id);
                children.forEach((child, i) => {
                    const side = i % 2 === 0 ? -1 : 1; // å·¦å³äº¤æ›¿
                    const layer = Math.floor(i / 2) + 1;
                    child.x = centerX + side * (150 + layer * 50);
                    child.y = centerY + (i % 2 === 0 ? -1 : 1) * layer * 60;
                    descendants.push(child);
                    
                    // å¤„ç†å­™èŠ‚ç‚¹
                    const grandChildren = this.nodes.filter(n => n.data.relations.parent === child.id);
                    grandChildren.forEach((grandChild, j) => {
                        grandChild.x = child.x + side * 100;
                        grandChild.y = child.y + (j - grandChildren.length / 2) * 40;
                        descendants.push(grandChild);
                    });
                });
                
                this.renderNodesAndLinksCustom(descendants);
            }

            // æ¸²æŸ“èŠ‚ç‚¹å’Œè¿çº¿çš„é€šç”¨æ–¹æ³•
            renderNodesAndLinks(descendants, links) {
                // æ¸²æŸ“è¿æ¥çº¿
                const link = this.linksGroup.selectAll('.link')
                    .data(links)
                    .enter().append('path')
                    .attr('class', 'link')
                    .attr('d', d3.linkHorizontal()
                        .x(d => d.x)
                        .y(d => d.y))
                    .attr('stroke', '#90a4ae')
                    .attr('stroke-width', 2)
                    .attr('fill', 'none');
                
                this.renderNodes(descendants);
            }

            // è‡ªå®šä¹‰è¿çº¿æ¸²æŸ“
            renderNodesAndLinksCustom(descendants) {
                // æ¸²æŸ“è¿æ¥çº¿ï¼ˆçˆ¶å­å…³ç³»ï¼‰
                const links = [];
                descendants.forEach(node => {
                    if (node.data && node.data.relations.parent) {
                        const parent = descendants.find(n => n.id === node.data.relations.parent);
                        if (parent) {
                            links.push({source: parent, target: node});
                        }
                    }
                });
                
                const link = this.linksGroup.selectAll('.link')
                    .data(links)
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y)
                    .attr('stroke', '#90a4ae')
                    .attr('stroke-width', 2);
                
                this.renderNodes(descendants);
            }

            // æ¸²æŸ“èŠ‚ç‚¹
            renderNodes(descendants) {
                const node = this.nodesGroup.selectAll('.node')
                    .data(descendants)
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x},${d.y})`)
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        this.selectNode(d.id || d.data.id);
                    })
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        this.editNode(d.id || d.data.id);
                    });
                
                // æ·»åŠ èŠ‚ç‚¹çŸ©å½¢
                node.append('rect')
                    .attr('width', d => Math.max(120, (d.title || d.data.title).length * 8 + 20))
                    .attr('height', 40)
                    .attr('x', d => -Math.max(60, (d.title || d.data.title).length * 4 + 10))
                    .attr('y', -20)
                    .attr('rx', 8)
                    .attr('ry', 8)
                    .attr('fill', d => (d.depth === 0 || (!d.data.relations.parent)) ? '#ff6b35' : '#4facfe')
                    .attr('stroke', d => (d.depth === 0 || (!d.data.relations.parent)) ? '#e55a2b' : '#0288d1')
                    .attr('stroke-width', 2);
                
                // æ·»åŠ èŠ‚ç‚¹æ–‡æœ¬
                node.append('text')
                    .text(d => {
                        const title = d.title || d.data.title;
                        return title.length > 15 ? title.substring(0, 15) + '...' : title;
                    })
                    .attr('dy', '.35em')
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '14px')
                    .attr('font-weight', '500');
                
                // æ·»åŠ èŠ‚ç‚¹æç¤º
                node.append('title')
                    .text(d => {
                        const title = d.title || d.data.title;
                        const content = d.content || d.data.content;
                        return `${title}\n\n${content.substring(0, 100)}...\n\nç‚¹å‡»é€‰æ‹© | åŒå‡»ç¼–è¾‘`;
                    });
                
                // å­˜å‚¨èŠ‚ç‚¹ä½ç½®ä¿¡æ¯
                this.nodes.forEach(n => {
                    const treeNode = descendants.find(d => (d.id || d.data.id) === n.id);
                    if (treeNode) {
                        n.x = treeNode.x;
                        n.y = treeNode.y;
                    }
                });
            }

            // è¾…åŠ©æ–¹æ³•
            groupByLevel() {
                const levels = {};
                const visited = new Set();
                
                const traverse = (nodeId, level = 0) => {
                    if (visited.has(nodeId)) return;
                    visited.add(nodeId);
                    
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (!node) return;
                    
                    if (!levels[level]) levels[level] = [];
                    levels[level].push(node);
                    
                    // æ‰¾å­èŠ‚ç‚¹
                    const children = this.nodes.filter(n => n.data.relations.parent === nodeId);
                    children.forEach(child => traverse(child.id, level + 1));
                };
                
                const rootNodes = this.nodes.filter(n => !n.data.relations.parent);
                rootNodes.forEach(root => traverse(root.id));
                
                return levels;
            }

            getLevelCounts(hierarchy) {
                const counts = [];
                const traverse = (node, depth = 0) => {
                    counts[depth] = (counts[depth] || 0) + 1;
                    if (node.children) {
                        node.children.forEach(child => traverse(child, depth + 1));
                    }
                };
                traverse(hierarchy);
                return counts;
            }

            getMaxDepth(hierarchy) {
                const getDepth = (node) => {
                    if (!node.children) return 1;
                    return 1 + Math.max(...node.children.map(getDepth));
                };
                return getDepth(hierarchy);
            }

            adjustForCollisions(nodes) {
                for (let i = 0; i < 3; i++) { // å¤šæ¬¡è¿­ä»£ä¼˜åŒ–
                    nodes.forEach((node, idx) => {
                        nodes.slice(idx + 1).forEach(other => {
                            const dx = node.x - other.x;
                            const dy = node.y - other.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDistance = 80;
                            
                            if (distance < minDistance && distance > 0) {
                                const pushX = (dx / distance) * (minDistance - distance) * 0.5;
                                const pushY = (dy / distance) * (minDistance - distance) * 0.5;
                                node.x += pushX;
                                node.y += pushY;
                                other.x -= pushX;
                                other.y -= pushY;
                            }
                        });
                    });
                }
            }

            buildHierarchy(root) {
                const addChildren = (node) => {
                    const children = this.nodes.filter(n => n.data.relations.parent === node.id);
                    if (children.length > 0) {
                        node.children = children.map(child => {
                            const childNode = {
                                id: child.id,
                                title: child.title,
                                content: child.content,
                                data: child.data
                            };
                            return addChildren(childNode);
                        });
                    }
                    return node;
                };
                
                return addChildren({
                    id: root.id,
                    title: root.title,
                    content: root.content,
                    data: root.data
                });
            }

            loadMarkdown(markdown) {
                const blocks = this.parseMarkdown(markdown);
                this.buildGraph(blocks);
                this.clear();
                this.render();
            }

            clear() {
                this.linksGroup.selectAll('*').remove();
                this.nodesGroup.selectAll('*').remove();
            }

            zoomIn() {
                this.svg.transition().call(this.zoom.scaleBy, 1.5);
            }

            zoomOut() {
                this.svg.transition().call(this.zoom.scaleBy, 1 / 1.5);
            }

            fitToView() {
                const bounds = this.container.node().getBBox();
                const parent = this.container.node().parentElement;
                const fullWidth = parent.clientWidth || parent.parentNode.clientWidth;
                const fullHeight = parent.clientHeight || parent.parentNode.clientHeight;
                
                if (bounds.width === 0 || bounds.height === 0) return;
                
                const midX = bounds.x + bounds.width / 2;
                const midY = bounds.y + bounds.height / 2;
                const scale = 0.8 / Math.max(bounds.width / fullWidth, bounds.height / fullHeight);
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                
                this.svg.transition()
                    .duration(750)
                    .call(this.zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
            }

            exportData() {
                const data = {
                    nodes: this.nodes,
                    links: this.links,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mindmap-data.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            updateStatus() {
                const statusText = document.getElementById('status-text');
                const selectedInfo = this.selectedNode ? ` | å·²é€‰æ‹©: ${this.selectedNode}` : '';
                statusText.textContent = `å°±ç»ª | èŠ‚ç‚¹æ•°: ${this.nodes.length} | è¿æ¥æ•°: ${this.links.length}${selectedInfo} | Enteræ·»åŠ åŒçº§ï¼ŒCtrl+Enteræ·»åŠ å­èŠ‚ç‚¹`;
            }
        }

        // åˆå§‹åŒ–è„‘å›¾
        const mindMap = new NodeMindMap('#mindmap-svg');

        // ç¤ºä¾‹æ•°æ®
        const examples = {
            project: `ç¼–å·ï¼š{#P001}
æ ‡é¢˜ï¼šäº§å“å¼€å‘é¡¹ç›®
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šé¡¹ç›®ç»ç†

äº§å“å¼€å‘çš„ä¸»è¦é¡¹ç›®ï¼ŒåŒ…å«éœ€æ±‚åˆ†æã€è®¾è®¡ã€å¼€å‘ã€æµ‹è¯•ç­‰å„ä¸ªé˜¶æ®µã€‚

å…³é”®ç›®æ ‡ï¼š
- æŒ‰æ—¶äº¤ä»˜é«˜è´¨é‡äº§å“
- æ»¡è¶³ç”¨æˆ·éœ€æ±‚
- æ§åˆ¶æˆæœ¬å’Œé£é™©

---
ã€æ ‡è®°æ—ã€‘
åˆ†ç±»æ ‡ç­¾ï¼š@é¡¹ç›®.ç®¡ç†.å¼€å‘
çŠ¶æ€æ ‡ç­¾ï¼š@è¿›è¡Œä¸­

ç¼–å·ï¼š{#P002}
æ ‡é¢˜ï¼šéœ€æ±‚åˆ†æ
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šäº§å“ç»ç†

æ·±å…¥åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œåˆ¶å®šäº§å“åŠŸèƒ½è§„æ ¼ã€‚

ä¸»è¦å·¥ä½œï¼š
- ç”¨æˆ·è°ƒç ”
- ç«å“åˆ†æ
- åŠŸèƒ½å®šä¹‰

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^P001
åˆ†ç±»æ ‡ç­¾ï¼š@é¡¹ç›®.éœ€æ±‚.åˆ†æ
çŠ¶æ€æ ‡ç­¾ï¼š@å·²å®Œæˆ

ç¼–å·ï¼š{#P003}
æ ‡é¢˜ï¼šç³»ç»Ÿè®¾è®¡
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šæ¶æ„å¸ˆ

åŸºäºéœ€æ±‚åˆ†æç»“æœï¼Œè®¾è®¡ç³»ç»Ÿæ¶æ„å’ŒæŠ€æœ¯æ–¹æ¡ˆã€‚

è®¾è®¡å†…å®¹ï¼š
- ç³»ç»Ÿæ¶æ„
- æ•°æ®åº“è®¾è®¡
- æ¥å£è®¾è®¡

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^P001
ä¾èµ–å…³ç³»ï¼šâ†P002
åˆ†ç±»æ ‡ç­¾ï¼š@é¡¹ç›®.è®¾è®¡.æ¶æ„
çŠ¶æ€æ ‡ç­¾ï¼š@è¿›è¡Œä¸­`,

            knowledge: `ç¼–å·ï¼š{#K001}
æ ‡é¢˜ï¼šå‰ç«¯å¼€å‘çŸ¥è¯†ä½“ç³»
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šæŠ€æœ¯ä¸“å®¶

å‰ç«¯å¼€å‘çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ï¼Œæ¶µç›–åŸºç¡€çŸ¥è¯†åˆ°é«˜çº§åº”ç”¨ã€‚

æ ¸å¿ƒé¢†åŸŸï¼š
- HTML/CSS/JavaScriptåŸºç¡€
- æ¡†æ¶ä¸åº“åº”ç”¨
- å·¥ç¨‹åŒ–ä¸ä¼˜åŒ–

---
ã€æ ‡è®°æ—ã€‘
åˆ†ç±»æ ‡ç­¾ï¼š@çŸ¥è¯†.å‰ç«¯.ä½“ç³»
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.JavaScript.æ¡†æ¶

ç¼–å·ï¼š{#K002}
æ ‡é¢˜ï¼šJavaScriptåŸºç¡€
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šæŠ€æœ¯ä¸“å®¶

JavaScriptè¯­è¨€çš„æ ¸å¿ƒæ¦‚å¿µå’ŒåŸºç¡€è¯­æ³•ã€‚

å­¦ä¹ é‡ç‚¹ï¼š
- å˜é‡ä¸æ•°æ®ç±»å‹
- å‡½æ•°ä¸ä½œç”¨åŸŸ
- å¼‚æ­¥ç¼–ç¨‹

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^K001
åˆ†ç±»æ ‡ç­¾ï¼š@çŸ¥è¯†.å‰ç«¯.åŸºç¡€
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.JavaScript.è¯­æ³•

ç¼–å·ï¼š{#K003}
æ ‡é¢˜ï¼šReactæ¡†æ¶
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šæŠ€æœ¯ä¸“å®¶

Reactæ¡†æ¶çš„æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µã€‚

æ ¸å¿ƒå†…å®¹ï¼š
- ç»„ä»¶åŒ–å¼€å‘
- çŠ¶æ€ç®¡ç†
- ç”Ÿå‘½å‘¨æœŸ

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^K001
ä¾èµ–å…³ç³»ï¼šâ†K002
åˆ†ç±»æ ‡ç­¾ï¼š@çŸ¥è¯†.å‰ç«¯.æ¡†æ¶
æŠ€æœ¯æ ‡ç­¾ï¼š@å‰ç«¯.React.ç»„ä»¶`,

            learning: `ç¼–å·ï¼š{#L001}
æ ‡é¢˜ï¼šæ•°æ®ç»“æ„ä¸ç®—æ³•
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå­¦ä¹ è€…

è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒè¯¾ç¨‹ï¼Œå­¦ä¹ å„ç§æ•°æ®ç»“æ„å’Œç®—æ³•ã€‚

å­¦ä¹ ç›®æ ‡ï¼š
- æŒæ¡åŸºæœ¬æ•°æ®ç»“æ„
- ç†è§£ç®—æ³•å¤æ‚åº¦
- åŸ¹å…»ç¼–ç¨‹æ€ç»´

---
ã€æ ‡è®°æ—ã€‘
åˆ†ç±»æ ‡ç­¾ï¼š@å­¦ä¹ .è®¡ç®—æœº.åŸºç¡€
çŠ¶æ€æ ‡ç­¾ï¼š@å­¦ä¹ ä¸­

ç¼–å·ï¼š{#L002}
æ ‡é¢˜ï¼šçº¿æ€§æ•°æ®ç»“æ„
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå­¦ä¹ è€…

æ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ç­‰çº¿æ€§æ•°æ®ç»“æ„ã€‚

ä¸»è¦å†…å®¹ï¼š
- æ•°ç»„æ“ä½œ
- é“¾è¡¨å®ç°
- æ ˆå’Œé˜Ÿåˆ—åº”ç”¨

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^L001
åˆ†ç±»æ ‡ç­¾ï¼š@å­¦ä¹ .æ•°æ®ç»“æ„.çº¿æ€§
çŠ¶æ€æ ‡ç­¾ï¼š@å·²æŒæ¡

ç¼–å·ï¼š{#L003}
æ ‡é¢˜ï¼šæ ‘å½¢æ•°æ®ç»“æ„
æ—¶é—´ï¼š2025-01-17 | 2025-01-17
ä½œè€…ï¼šå­¦ä¹ è€…

äºŒå‰æ ‘ã€å¹³è¡¡æ ‘ã€Bæ ‘ç­‰æ ‘å½¢ç»“æ„ã€‚

é‡ç‚¹æ¦‚å¿µï¼š
- äºŒå‰æ ‘éå†
- å¹³è¡¡æ ‘åŸç†
- æ ‘çš„åº”ç”¨åœºæ™¯

---
ã€æ ‡è®°æ—ã€‘
çˆ¶å­å…³ç³»ï¼š^L001
ä¾èµ–å…³ç³»ï¼šâ†L002
åˆ†ç±»æ ‡ç­¾ï¼š@å­¦ä¹ .æ•°æ®ç»“æ„.æ ‘å½¢
çŠ¶æ€æ ‡ç­¾ï¼š@å­¦ä¹ ä¸­`
        };

        // åŠ è½½ç¤ºä¾‹
        function loadExample(type) {
            document.getElementById('markdown-input').value = examples[type];
            updateMindMap();
        }

        // æ›´æ–°è„‘å›¾
        function updateMindMap() {
            const markdown = document.getElementById('markdown-input').value;
            if (markdown.trim()) {
                mindMap.loadMarkdown(markdown);
            }
        }

        // æ›´æ–°å¸ƒå±€
        function updateLayout() {
            updateMindMap();
        }

        // åˆå§‹åŒ–åŠ è½½
        window.addEventListener('load', () => {
            updateMindMap();
        });

        // å…¨å±€å‡½æ•°ä¾›HTMLè°ƒç”¨
        function saveNodeContent() {
            mindMap.saveNodeContent();
        }

        function cancelNodeEdit() {
            mindMap.cancelNodeEdit();
        }
    </script>
</body>
</html> 